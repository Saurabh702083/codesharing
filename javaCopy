@Service
@RequiredArgsConstructor
public class DataSyncService {

    private final LoggerUtility log = LoggerFactoryUtility.getLogger(this.getClass());

    private final MerchantOrderPaymentMapper paymentMapper;
    private final OrderMapper orderMapper;
    private final ReconStatusUpdatePublisher reconStatusUpdateProducer;
    private final MerchantOrderDao merchantOrderDao;
    private final MerchantOrderPaymentDao merchantOrderPaymentDao;

    @Value("${spring.jpa.properties.hibernate.jdbc.batch_size}")
    private int batchSize;

    /**
     * Syncing of data from view tables to Operation DB by Schedular and publishing the ATRN to
     * the Transaction service for updating its status
     */
    public void syncTransactionData() {
        //Step 1. Syncing Data from OrderReconView to MerchantOrder Table
        log.info("Syncing data to MerchantOrder table at : {}", System.currentTimeMillis());
        syncOrderData();
        //Step 2. Syncing Data from PaymentReconView to MerchantOrderPayment Table.
        log.info("Syncing data to MerchantOrderPayment table at : {}", System.currentTimeMillis());
        List<PaymentReconView> paymentReconViews = syncPaymentData();
        //Step 3. Kafka producer for updating Transaction status
        log.info("Kafka producer for updating Status  ");
        statusProducer(paymentReconViews);
    }

    /**
     * Syncing or data from OrderReconView to MerchantOrder Table
     */
    @Transactional
    public void syncOrderData() {

        log.info("Getting data from merchant order View ");
        List<OrderReconView> allOrderViewData = merchantOrderDao.getAllOrderViewData();
        List<Order> orders = orderMapper.toOrderList(allOrderViewData);
        log.info("updating the Merchant order table");
        merchantOrderDao.updateMerchantOrder(orders);
    }

    /**
     * Syncing or data from OrderPaymentReconView to MerchantOrderPayment  Table
     *
     * @return List of PaymentReconView
     */
    @Transactional
    public List<PaymentReconView> syncPaymentData() {
        log.info("Getting data from merchant order payment View ");
        List<PaymentReconView> allPaymentViewData = merchantOrderPaymentDao.getAllPaymentViewData();
        List<MerchantOrderPayment> merchantPayments = paymentMapper.toPaymentList(allPaymentViewData);
        log.info("updating the Merchant order payment table ");
        merchantOrderPaymentDao.updateOrderPayment(merchantPayments);
        return allPaymentViewData;
    }

    /**
     * Publishing ATRN to Transaction service by Kafka
     *
     * @param paymentReconViews List of PaymentReconView
     */
    public void statusProducer(List<PaymentReconView> paymentReconViews) {
        log.info("Publishing the ATRN ");
        paymentReconViews.forEach(paymentReconView -> {
            String atrnNumber = paymentReconView.getAtrnNum();
            SettlementStatusDto settlementStatusDto = SettlementStatusDto.builder().status(SETTLED).atrn(atrnNumber).build();
            reconStatusUpdateProducer.publish(UPDATE_STATUS, atrnNumber, settlementStatusDto);
        });
        log.info("Finished pushing ATRN to Transaction service");
    }
}


@Component
@RequiredArgsConstructor
public class MerchantOrderDao {
    private final OrderReconViewRepository orderViewRepo;
    private final MerchantOrderRepository orderRepository;

    public List<OrderReconView> getAllOrderViewData() {
        return orderViewRepo.findAll();
    }

    public void updateMerchantOrder (List<Order> orders){
        orderRepository.updateOrder(orders);
    }


}

@Component
@RequiredArgsConstructor
public class MerchantOrderPaymentDao {
    private final PaymentReconViewRepository paymentViewRepo;
    private final OrderPaymentRepository orderPaymentRepository;
    private final MerchantOrderPaymentMapper orderPaymentMapper;

    public List<PaymentReconView> getAllPaymentViewData() {
        return paymentViewRepo.findAll();
    }

    public void updateOrderPayment(List<MerchantOrderPayment> orderPayments){
        orderPaymentRepository.updateMerchantOrderPayment(orderPayments);
    }

    public List<MerchantOrderPaymentDto>  getMatchedData(UUID rfsId){
         return orderPaymentMapper.toPaymentDtoList(orderPaymentRepository.getAllbyRfsId(rfsId));
    }
}

@Component
@RequiredArgsConstructor
public class ReconStatusUpdatePublisher extends ReconProducer<SettlementStatusDto>{
    private final LoggerUtility log = LoggerFactoryUtility.getLogger(this.getClass());
    private final ObjectMapper objectMapper;

    /**
     * @param requestType String
     * @param routingKey  String
     * @param settlementStatusDto  SettlementStatusDto
     */
    @Override
    public void publish(String requestType, String routingKey, SettlementStatusDto settlementStatusDto) {
        try {
            log.debug("Recon update Settlement for requestType : {}, routingKey : {} and value : {}", requestType, routingKey, settlementStatusDto);
            kafkaMessagePublisher.publish(topics.getReconStatusUpdateTopic(), getRoutingKey("recon", requestType, routingKey), objectMapper.writeValueAsString(settlementStatusDto));
        } catch (Exception e) {
            log.error("Error in Recon Status update , SettlementStatusDto {}", settlementStatusDto, e.getMessage());
        }
    }
}

@Getter
@Setter
@Entity
@Table(name = "ORDER_RECON_VIEW")
public class OrderReconView {

    private String sbiOrderRefNumber;
    @Id
    private String atrnNum;
    @Lob
    private String multiAccounts;

}

@Getter
@Setter
@Entity
@Table(name = "MERCHANT_ORDERS")
public class Order  {

        @Id
        private String atrnNum;
        private String sbiOrderRefNumber;
        @Lob
        private String multiAccounts;
}

@Getter
@Setter
@Entity
@Table(name = "PAYMENT_RECON_VIEW")
public class PaymentReconView {
    @Id
    private String atrnNum;
    @Column(name="MERCHANT_ID")
    private String mId;
    private String sbiOrderRefNumber;
    private BigDecimal orderAmount;
    private BigDecimal debitAmt;
    @Enumerated(EnumType.STRING)
    private PaymentStatus paymentStatus;
    @Enumerated(EnumType.STRING)
    private TransactionStatus transactionStatus;
    private Date paymentSuccessDate;
}

@Getter
@Setter
@Entity
@Table(name = "MERCHANT_ORDER_PAYMENTS")
@EqualsAndHashCode
public class MerchantOrderPayment {
        @Id
        private String atrnNum;
        @Column(name="MERCHANT_ID")
        private String mId;
        private String sbiOrderRefNumber;
        private BigDecimal orderAmount;
        private BigDecimal debitAmt;
        @Enumerated(EnumType.STRING)
        private PaymentStatus paymentStatus;
        @Enumerated(EnumType.STRING)
        private TransactionStatus transactionStatus;
        private Date paymentSuccessDate;
}

@Data
@AllArgsConstructor
@NoArgsConstructor
public class MerchantOrderPaymentDto implements Serializable {

    private String mId;
    private String orderRefNumber;
    private String sbiOrderRefNumber;
    private String atrnNum;
    private BigDecimal debitAmt;
    private BigDecimal orderAmount;
    private PaymentStatus paymentStatus;
    private TransactionStatus transactionStatus;
    private Date paymentSuccessDate;
}
------------------------------------------------------------------
Above is my code for DatasyncService now i want to generate J unit 5 test case for the service and dao layer. 
can you create J unit 5 test case for above code for service and dao class.
