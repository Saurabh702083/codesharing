@Service
public class ReconService {

    @Autowired
    private MerchantOrderPaymentRepository mopRepository;

    @Autowired
    private ReconFileDitlRepository reconFileDitlRepository;

    public ReconResultDTO processReconciliation() {
        ReconResultDTO result = new ReconResultDTO();

        List<MerchantOrderPayment> mopList = mopRepository.findAll();
        List<ReconFileDitl> reconList = reconFileDitlRepository.findAll();

        // Build MOP Map (ATRN -> MerchantOrderPayment)
        Map<String, MerchantOrderPayment> mopMap = mopList.stream()
            .collect(Collectors.toMap(MerchantOrderPayment::getAtrn, Function.identity()));

        // Build Recon Map (ATRN -> List<ReconFileDitl>)
        Map<String, List<ReconFileDitl>> reconMap = new HashMap<>();
        for (ReconFileDitl recon : reconList) {
            reconMap.computeIfAbsent(recon.getAtrn(), k -> new ArrayList<>()).add(recon);
        }

        // Process Matching
        for (Map.Entry<String, List<ReconFileDitl>> entry : reconMap.entrySet()) {
            String atrn = entry.getKey();
            List<ReconFileDitl> reconRecords = entry.getValue();

            if (mopMap.containsKey(atrn)) {
                if (reconRecords.size() == 1) {
                    result.getMatchedReconRecords().addAll(reconRecords);
                } else {
                    result.getDuplicateReconRecords().addAll(reconRecords);
                }
            } else {
                result.getUnmatchedReconRecords().addAll(reconRecords);
            }
        }

        // Set counts
        result.setMatchedCount(result.getMatchedReconRecords().size());
        result.setUnmatchedCount(result.getUnmatchedReconRecords().size());
        result.setDuplicateCount(result.getDuplicateReconRecords().size());

        return result;
    }
}



public class ReconResultDTO {

    private long matchedCount;
    private long unmatchedCount;
    private long duplicateCount;

    private List<ReconFileDitl> matchedReconRecords;
    private List<ReconFileDitl> unmatchedReconRecords;
    private List<ReconFileDitl> duplicateReconRecords;

    public ReconResultDTO() {
        this.matchedReconRecords = new ArrayList<>();
        this.unmatchedReconRecords = new ArrayList<>();
        this.duplicateReconRecords = new ArrayList<>();
    }

    // Getters and Setters
}

@Repository
public interface ReconRepository extends JpaRepository<ReconFileDitl, Long> {

    @Query(value = "SELECT r.atrn, COUNT(*) as count " +
                   "FROM recon_file_ditl r " +
                   "JOIN merchant_order_payment m ON r.atrn = m.atrn " +
                   "GROUP BY r.atrn " +
                   "HAVING COUNT(*) = 1", nativeQuery = true)
    List<Object[]> findMatchedATRNs();

    @Query(value = "SELECT r.atrn, COUNT(*) as count " +
                   "FROM recon_file_ditl r " +
                   "LEFT JOIN merchant_order_payment m ON r.atrn = m.atrn " +
                   "WHERE m.atrn IS NULL " +
                   "GROUP BY r.atrn", nativeQuery = true)
    List<Object[]> findUnmatchedATRNs();

    @Query(value = "SELECT r.atrn, COUNT(*) as count " +
                   "FROM recon_file_ditl r " +
                   "JOIN merchant_order_payment m ON r.atrn = m.atrn " +
                   "GROUP BY r.atrn " +
                   "HAVING COUNT(*) > 1", nativeQuery = true)
    List<Object[]> findDuplicateATRNs();
}

@Repository
public interface MerchantOrderPaymentRepository extends JpaRepository<MerchantOrderPayment, String> {

    List<MerchantOrderPayment> findByAtrn(String atrn);
}

@Repository
public interface ReconFileDitlRepository extends JpaRepository<ReconFileDitl, Long> {

    List<ReconFileDitl> findByAtrn(String atrn);
}



@Service
public class ReconService {

    @Autowired
    private ReconRepository reconRepository;

    @Autowired
    private MerchantOrderPaymentRepository mopRepository;

    @Autowired
    private ReconFileDitlRepository reconFileDitlRepository;

    public List<ReconResponseDTO> getMatchedATRNs() {
        List<Object[]> rawData = reconRepository.findMatchedATRNs();
        return buildResponseDTOs(rawData);
    }

    public List<ReconResponseDTO> getUnmatchedATRNs() {
        List<Object[]> rawData = reconRepository.findUnmatchedATRNs();
        return buildResponseDTOs(rawData);
    }

    public List<ReconResponseDTO> getDuplicateATRNs() {
        List<Object[]> rawData = reconRepository.findDuplicateATRNs();
        return buildResponseDTOs(rawData);
    }

    private List<ReconResponseDTO> buildResponseDTOs(List<Object[]> rawData) {
        List<ReconResponseDTO> result = new ArrayList<>();

        for (Object[] row : rawData) {
            String atrn = (String) row[0];
            long count = ((BigInteger) row[1]).longValue();

            List<ReconFileDitl> reconRecords = reconFileDitlRepository.findByAtrn(atrn);
            List<MerchantOrderPayment> mopRecords = mopRepository.findByAtrn(atrn);

            result.add(new ReconResponseDTO(atrn, count, reconRecords, mopRecords));
        }

        return result;
    }
}
