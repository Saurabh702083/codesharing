@Service
@RequiredArgsConstructor
public class OpsReportService {

    private static final List<String> MERCHANT_PAYOUT_HEADER = List.of("MERCHANT ID", "MERCHANT NAME", "TRANSACTION AMOUNT", "TRANSACTION CURRENCY", "SETTLEMENT AMOUNT", "SETTLEMENT CURRENCY", "COMMISSION PAYABLE", "GST", "PAYOUT AMOUNT", "REFUND AMOUNT", "TDR ON REFUND AMOUNT", "GST ON REFUND AMOUNT", "NET REFUND AMOUNT", "NET PAYOUT AMOUNT", "PAYOUT DATE", "TRANSACTION COUNT", "CHARGEBACK AMOUNT");
    private static final List<String> TRANSACTION_REFUND_HEADER = List.of("SETTLEMENT FILE NUMBER", "SETTLEMENT DATE", "MERCHANT ID", "MERCHANT NAME", "MERCHANT ORDER NUMBER", "TRANSACTION ID", "TRANSACTION BOOKING DATE & TIME", "TRANSACTION CURRENCY", "TRANSACTION AMOUNT", "REFUND CURRENCY", "REFUND AMOUNT", "COMMISSION PAYABLE", "GST", "NET REFUND AMOUNT", "GATEWAY NAME", "GATEWAY TRACE NO", "PAY MODE CODE", "REFUND TYPE", "REFUND BOOKING DATE", "ARRN NO");
    private static final List<String> TRANSACTION_MIS_HEADER = List.of("MERCHANT ID", "MERCHANT NAME", "MERCHANT CATEGORY", "MERCHANT ORDER NO", "TRANSACTION ID", "INSTRUCTION DATE AND TIME", "TRANSACTION CURRENCY", "MERCHANT ORDER AMOUNT", "TOTAL FEE ABS", "GST", "GATEWAY POSTING AMOUNT", "AMOUNT SETTLED", "AVAILABLE REFUND AMOUNT", "PAY MODE CODE", "PAY GATEWAY", "GATEWAY TRACE NUMBER", "STATUS", "REMARK", "MERCHANT RISK CATEGORY", "ACCESS MEDIUM", "PAY PROC", "PAY PROC TYPE", "MERCHANT AUTHORIZE", "MERCHANT AUTHORIZE DATE", "AUTO SETTLEMENT", "TRANSACTION FEE FLAG", "CIN NUMBER", "RESPONSE REASON", "MERCHANT BEARABLE FEE", "MERCHANT BEARABLE GST", "CUSTOMER BEARABLE FEE", "CUSTOMER BEARABLE GST", "SUB STATUS DESCRIPTION", "PAYMENT SUCCESS DATE");
    private static final List<String> TRANSACTION_PAYOUT_HEADER = List.of("SETTLEMENT FILE NUMBER", "SETTLEMENT DATE", "MERCHANT ID", "MERCHANT NAME", "MERCHANT ORDER NO", "TRANSACTION ID", "TRANSACTION BOOKING DATE & TIME", "TRANSACTION CURRENCY", "TRANSACTION AMOUNT", "SETTLEMENT CURRENCY", "SETTLEMENT AMOUNT", "COMMISSION PAYABLE", "GST", "PAYOUT AMOUNT", "GATEWAY NAME", "GATEWAY TRACE NUMBER", "PAY MODE CODE", "PAY PROC", "OTHER DETAILS", "TRANSACTION FEE FLAG", "CIN NUMBER");
    private static final List<String> SBI_EPAY_AGG_BANK_HEADER = List.of("MERCHANT ID", "MERCHANT CATEGORY", "MERCHANT NAME", "MERCHANT ORDER NUMBER", "TRANSACTION ID", "TRANSACTION BOOKING DATE & TIME", "TRANSACTION AMOUNT", "TRANSACTION CURRENCY", "TRANSACTION STATUS", "ETL UPLOAD DATE", "ETL STATUS", "GATEWAY NAME", "GATEWAY TRACE NUMBER", "PAY MODE CODE", "GATEWAY STATUS");

    private final LoggerUtility log = LoggerFactoryUtility.getLogger(this.getClass());

    private final FileGeneratorService fileGeneratorService;
    private final S3Service s3Service;
    private final OpsReportDao opsReportDao;
    private final OpsReportConfirmationPublisher reportConfirmationPublisher;
    private final ObjectMapper objectMapper;

    public void reportGeneration(OpsReportRequestDto opsReportRequestDto) {
        log.info("Processing OpsReportRequestDto with reportType: {}", opsReportRequestDto.getReportType());
        try {
            switch (opsReportRequestDto.getReportType()) {
                case TRANSACTION_WISE_PAYOUT_MIS ->
                        generateCsvReport(TRANSACTION_PAYOUT_HEADER, opsReportDao.getTransactionMerchantPayouts(opsReportRequestDto.getReportFilter()), TRANSACTION_WISE_PAYOUT_MIS, opsReportRequestDto.getRrId());
                case MERCHANT_WISE_PAYOUT_MIS ->
                        generateCsvReport(MERCHANT_PAYOUT_HEADER, opsReportDao.getMerchantPayoutData(opsReportRequestDto.getReportFilter()), MERCHANT_WISE_PAYOUT_MIS, opsReportRequestDto.getRrId());
                case TRANSACTION_WISE_REFUND_MIS ->
                        generateCsvReport(TRANSACTION_REFUND_HEADER, opsReportDao.getTransactionRefundData(opsReportRequestDto.getReportFilter()), TRANSACTION_WISE_REFUND_MIS, opsReportRequestDto.getRrId());
                case NEFT_PAYOUT ->
                        generateTxtReport(NEFT_PAYOUT, opsReportRequestDto.getRrId(), opsReportDao.getNEFTMerchantAccountPayoutDao(opsReportRequestDto.getReportFilter()));
                default ->
                        throw new ReportingException(INVALID_ERROR_CODE, MessageFormat.format(INVALID_ERROR_MESSAGE, REPORT_TYPE, opsReportRequestDto.getReportType()));
            }

        } catch (ReportingException ex) {
            publishReportConfirmation(opsReportRequestDto.getRrId(),null,opsReportRequestDto.getReportType(), ex.getErrorMessage());
            log.info("Error in report generation for ReportRequestId :{} and Report Type : {} ",opsReportRequestDto.getRrId(),opsReportRequestDto.getReportType());
        }catch (Exception e){
            publishReportConfirmation(opsReportRequestDto.getRrId(),null,opsReportRequestDto.getReportType(), e.getMessage());
            log.info("Error in report generation for ReportRequestId :{} and Report Type : {} ",opsReportRequestDto.getRrId(),opsReportRequestDto.getReportType());
        }
    }
    private void generateCsvReport(List<String> header, List<List<Object>> data, Report report, UUID rrId) {
        ReportFile reportFile = fileGeneratorService.generateFile(ReportFormat.CSV, report, header, data);
        uploadFileOnS3(reportFile, rrId, ReportFormat.CSV, report);
    }

    private void generateTxtReport(Report report, UUID rrId, List<String> lines) {
        ReportFile reportFile = fileGeneratorService.generateFile(report, TxtFileModel.builder().lines(lines).build());
        uploadFileOnS3(reportFile, rrId, ReportFormat.TXT, report);
    }

    private void uploadFileOnS3(ReportFile reportFile, UUID rrId, ReportFormat reportFormat, Report report) {
        String s3FileName = s3Service.uploadFile(reportFile.getName(), reportFile.getContent(), false);
        log.info("Report uploaded to S3 with file name: {}", s3FileName);
        opsReportDao.saveReport(rrId, reportFormat, s3FileName);
        log.info("Report data saved in DB for ReportID: {}", rrId);
        publishReportConfirmation(rrId, s3FileName, report,"SUCCESS");
    }
    private void publishReportConfirmation(UUID id, String s3FilePath, Report report,String remark) {
        try {
            String reportConfirmationMessage = objectMapper.writeValueAsString(ReportResponseDto.builder().rrId(id).s3FilePath(s3FilePath).remark(remark).build());
            reportConfirmationPublisher.publish(StringUtils.join(report.getName(), "_", id), reportConfirmationMessage);
        } catch (Exception e) {
            log.error("Error in publishing alert", e);
        }
    }
}
------------------------
@Component
@RequiredArgsConstructor
public class OpsReportDao {

    private final ReportManagementDao reportManagementDao;
    private final TransactionMISDao transactionMISDao;
    private final TransactionMerchantPayoutDao transactionMerchantPayoutDao;
    private final SBIAccountPayoutDao sbiAccountPayoutDao;
    private final MerchantAccountPayoutRepository merchantAccountPayoutRepository;
    private final MerchantPayoutDao merchantPayoutDao;
    private final TransactionRefundDao transactionRefundDao;

    public List<List<Object>> getTransactionMISByMID(ReportFilterDto reportFilterDto){
        return transactionMISDao.getTransactionMISByMID(reportFilterDto.getMId());
    }

    public List<List<Object>> getTransactionMerchantPayouts(ReportFilterDto reportFilterDto){
        return transactionMerchantPayoutDao.getTransactionMerchantPayouts(reportFilterDto.getMpIdList());
    }

    public List<List<Object>> getSBIAccountPayouts(ReportFilterDto reportFilterDto){
        return sbiAccountPayoutDao.getSBIAccountPayouts(reportFilterDto.getMId());
    }

    public List<String> getAATMerchantAccountPayoutDao(ReportFilterDto reportFilterDto) {
        List<String> aatStringList=merchantAccountPayoutRepository.fetchAatMerchantPayout(reportFilterDto.getMpIdList());
        if(aatStringList.isEmpty()){
            throw new ReportingException(ErrorConstants.NOT_FOUND_ERROR_CODE, ERROR_WHILE_FETCHING_THE_LIST);
        }
        return aatStringList;
    }

    public List<String> getNEFTMerchantAccountPayoutDao(ReportFilterDto reportFilterDto) {
        List<String> neftStringList= merchantAccountPayoutRepository.fetchNeftMerchantPayout(reportFilterDto.getMpIdList());
        if(neftStringList.isEmpty()){
            throw new ReportingException(ErrorConstants.NOT_FOUND_ERROR_CODE, ERROR_WHILE_FETCHING_THE_LIST);
        }
        return neftStringList;
    }

    public List<List<Object>> getTransactionRefundData(ReportFilterDto reportFilterDto) {
        return transactionRefundDao.getTransactionRefundData(reportFilterDto.getMpIdList());
    }

    public List<List<Object>> getMerchantPayoutData(ReportFilterDto reportFilterDto) {
        return merchantPayoutDao.getMerchantPayoutData(reportFilterDto.getMpIdList());
    }

    public void saveReport(UUID rrId, ReportFormat reportFormat, String filePath){
        ReportManagementDto reportDto = ReportManagementDto.builder().reportId(rrId).durationFromDate(0L).mId("0000000").durationToDate(0L).format(reportFormat).status(ReportStatus.GENERATED).remarks("Report request from operation service").filePath(filePath).build();
        reportManagementDao.saveReport(reportDto);
    }
}
-----------------
@Service
@RequiredArgsConstructor
public class TransactionMerchantPayoutDao {
    private final ViewTransactionWisePayoutRepository viewTransactionWisePayoutRepository;
    private final TransactionMerchantPayoutMapper transactionMerchantPayoutMapper;

    public List<List<Object>> getTransactionMerchantPayouts(List<UUID> mpId){
        List<TransactionPayout> viewTransactionMis = viewTransactionWisePayoutRepository.fetchTransactionMerchantPayouts(mpId);
        if (viewTransactionMis.isEmpty()){
            throw new ReportingException(ErrorConstants.NOT_FOUND_ERROR_CODE, MessageFormat.format(ErrorConstants.NOT_FOUND_ERROR_MESSAGE, MP_ID));
        }
        return viewTransactionMis.stream().map(transactionMerchantPayoutMapper::mapToList).collect(Collectors.toList());
    }
}

----------------
@Repository
@RequiredArgsConstructor
public class ViewTransactionWisePayoutRepository {
    private final NamedParameterJdbcTemplate jdbcTemplate;

    public List<TransactionPayout> fetchTransactionMerchantPayouts(List<UUID> mpId) {
        List<String> mpIdString = mpId.stream().map(id -> id.toString().replace("-", "").toUpperCase()).toList();
        MapSqlParameterSource params = new MapSqlParameterSource();
        params.addValue("mpId", mpIdString);
        return jdbcTemplate.query(GET_TRANSACTION_WISE_PAYOUT, params, new BeanPropertyRowMapper<>(TransactionPayout.class));
    }
}
--------------------
 public static final String GET_TRANSACTION_WISE_PAYOUT = """
    SELECT
        SETTLEMENT_FILE_NUMBER AS settlementFileNumber,
        SETTLEMENT_TIME AS settlementTime,
        MERCHANT_ID AS mId,
        MERCHANT_NAME AS merchantName,
        ORDER_REF_NUMBER AS orderRefNumber,
        ATRN_NUM AS atrnNum,
        CREATED_DATE AS createdDate,
        CURRENCY_CODE AS currencyCode,
        ORDER_AMOUNT AS orderAmount,
        SETTLEMENT_CURRENCY AS settlementCurrency,
        SETTLEMENT_AMOUNT AS settlementAmount,
        COMMISSION_PAYABLE AS commissionPayable,
        MERCHANT_GST_BEARABLE_ABS AS merchantGstBearableAbs,
        PAYOUT_AMOUNT AS payoutAmount,
        CHANNEL_BANK AS channelBank,
        GATEWAY_TRACE_NUMBER AS gatewayTraceNumber,
        PAY_MODE AS payMode,
        PAY_PROC_ID AS payProcId,
        OTHER_DETAILS AS otherDetails,
        BEARABLE_ENTITY AS bearableEntity,
        CIN AS cin
    FROM VIEW_TRANSACTION_WISE_PAYOUT_FORMAT
    WHERE HEXTORAW(MP_ID) IN (:mpId)
    """;

--------------------
@Repository
@RequiredArgsConstructor
public class MerchantAccountPayoutRepository {
    private final NamedParameterJdbcTemplate jdbcTemplate;

    public List<String> fetchNeftMerchantPayout(List<UUID> listMpId) {
        List<String> mpIdString=listMpId.stream().map(id -> id.toString().replace("-","").toUpperCase()).toList();
        MapSqlParameterSource params = new MapSqlParameterSource();
        params.addValue("mpId", mpIdString);
        return jdbcTemplate.query(NEFT_MERCHANT_ACCOUNT_PAYOUT,params,((rs, rowNum) -> rs.getString(1)));
    }
}
--------------
public static final String NEFT_MERCHANT_ACCOUNT_PAYOUT ="""
        SELECT
              'R41' ||--TYPE
              LPAD(REPLACE(TO_CHAR((A.PAYOUT_AMOUNT-A.REFUNDED_AMOUNT),'FM9999999990.00'),'.',''), 16, '0') ||--FINAL_PAYOUT
              LPAD((0), 16,0) ||--COMMISSION AMOUNT
              LPAD(33324315125, 19, 0) ||--SBIACCNO
              RPAD('SBIePay', 35)|| --REMITTER NAME
              RPAD('State Bank of India Payment Aggregator', 35)||--REMITTER ADDRESS
              RPAD((A.ACCOUNT_NUMBER),32)||--BENEFI ACC NO
              RPAD(C.ACCHOLDERNAME, 35)||--BENEFI NAME
              RPAD(D.MERCHANTOFFICEADDRESS, 35)||--BENEFI ADDRESS
              RPAD(B.IFSCCODE,11)||----BENEFI IFSC
              RPAD('SETTLEMENTTOMERCHANTACCOUNT', 35)||
              RPAD('URGENT', 35)||
              RPAD('SBIePAY PAYMENT', 58)||
              RPAD('ATRN000001436573ops@sbiepay.in', 51) AS "PAYOUT DETAILS"
    FROM MERCHANT_PAYOUT A,BANKBRANCHES B ,AGGMERCHANTBANKACCOUNTS C,AGGREGATORMERCHANT D
    WHERE A.BANK_ID=B.BANKID
    and B.BANKID=c.BANKID
    AND B.IFSCCODE=C.BRANCHCODE----------------NEED TO ADD THIS CONDITION
    AND A.ACCOUNT_ID=C.ACCOUNTID
    AND A.ACCOUNT_NUMBER=C.ACCOUNTNUMBER(+)
    AND A.MERCHANT_ID=D.MERCHANTID
    AND C.MERCHANTID=D.MERCHANTID
    AND HEXTORAW(A.MP_ID) IN (:mpId)
""";
-----------------------
@Service
@RequiredArgsConstructor
public class FileGeneratorService {
    private final LoggerUtility log = LoggerFactoryUtility.getLogger(this.getClass());
    private final FileGenerator fileGenerator;
    private final ZipFileGenerator zipFileGenerator;
    private final S3Service s3Service;
  public ReportFile generateFile(ReportFormat reportFormat, Report report, List<String> header, List<List<Object>> fileData) {
        FileModel fileModel = buildFileModel(reportFormat, header, fileData, null);
        log.info("Started fileGenerator for reportFormat: {}, report: {}", reportFormat, report.getName());
        return fileGenerator.generateFile(reportFormat, report, fileModel);
    }
  public ReportFile generateFile(Report report, TxtFileModel txtFileModel) {
        log.info("Started fileGenerator for reportFormat: TXT, report: {}", report.getName());
        return fileGenerator.generateFile(report, txtFileModel);
    }
}
------------------------
@Component
@RequiredArgsConstructor
public class FileGenerator {
    private static final LoggerUtility logger = LoggerFactoryUtility.getLogger(FileGenerator.class);
    private final PdfGenerator pdfGenerator;
    private final TxtGenerator txtGenerator;

  public ReportFile generateFile(ReportFormat reportFormat, Report report, FileModel fileModel) {
        logger.info("Generating file for report format: {}, report: {}, mId: {}", reportFormat, report.getName());
        CSVFileModel csvFileModel = (CSVFileModel) fileModel;
        return CSVGenerator.csvFileGenerator(report.getName(), csvFileModel.getHeaders(), csvFileModel.getFileData());
    }
  public ReportFile generateFile(Report report, TxtFileModel txtFileModel){
        logger.info("Generating file for report format: TXT, report: {}", report.getName());
        return txtGenerator.txtFileGenerator(report,txtFileModel);
    }}
--------------
@NoArgsConstructor(access = AccessLevel.PRIVATE)
public class CSVGenerator {
 protected static ReportFile csvFileGenerator(String reportName, List<String> headerName, List<List<Object>> objects) {
        log.info("Started csv file generator for reportName : {}, mId {}, headerName: {},  objects.size: {}", reportName, headerName, CollectionUtils.size(objects));
        String fileName = getFileName(reportName);
        String csvContent = generateCSV(headerName, objects);
        return ReportFile.builder().name(fileName).content(csvContent.getBytes(StandardCharsets.UTF_8)).build();
    }
  private static String getFileName(String reportName) {
        return String.format("%s%s_%s.csv", ReportingConstant.REPORT_ROOT_FOLDER, StringEscapeUtils.escapeJava(reportName), LocalDateTime.now().format(FORMATTER_DD_MM_YY_HH_MM_SS));
    }
  private static String generateCSV(List<String> headers, List<List<Object>> objects) {
        StringBuilder csvContent = new StringBuilder();
        csvContent.append(String.join(",", headers)).append("\n");
        for (List<Object> rowData : objects) {
            String row = rowData.stream()
                    .map(data -> ObjectUtils.isNotEmpty(data) ? data.toString() : StringUtils.EMPTY)
                    .collect(Collectors.joining(","));
            csvContent.append(row).append("\n");
        }
        return csvContent.toString();
    }
-----------------------
@Component
@RequiredArgsConstructor
public class TxtGenerator {
    private final LoggerUtility log = LoggerFactoryUtility.getLogger(this.getClass());

    public ReportFile txtFileGenerator(Report reportName, TxtFileModel txtFileModel) {
        log.info("Started txt file generator for reportName : {}  objects.size: {}", reportName.getName(),  CollectionUtils.size(txtFileModel.getLines()));
        String fileName = getFileName(reportName.getName());
        String content = generateTxt(txtFileModel);
        return ReportFile.builder().name(fileName).content(content.getBytes(StandardCharsets.UTF_8)).build();
    }

    private String getFileName(String reportName) {
        return String.format("%s%s_%s.txt", ReportingConstant.REPORT_ROOT_FOLDER,
                reportName, LocalDateTime.now().format(FORMATTER_DD_MM_YY_HH_MM_SS));
    }

    private String generateTxt(TxtFileModel txtFileModel){
        return String.join("\n", txtFileModel.getLines());
    }
}

Above is my code to generate Report based upon Report Type. Based upon report type and requriment its generate CSV ot TXT file. And right now in my code of there is any error in fetching the data from DB it will throw up an error .
so my new requriment is that if there is any error in fecthing the data it should ideal generate black file. and in case of csv file it should generate blank file with header if we gets empty list while fetching the data and in case of txt file it should generate
blanck txt file as there is no header in txt file if while featching the data we gets empty list of string.

