@Service
public class ReconService {

    @Autowired
    private MerchantOrderPaymentRepository mopRepository;

    @Autowired
    private ReconFileDitlRepository reconFileDitlRepository;

    public ReconResultDTO processReconciliation() {
        ReconResultDTO result = new ReconResultDTO();

        List<MerchantOrderPayment> mopList = mopRepository.findAll();
        List<ReconFileDitl> reconList = reconFileDitlRepository.findAll();

        // Build MOP Map (ATRN -> MerchantOrderPayment)
        Map<String, MerchantOrderPayment> mopMap = mopList.stream()
            .collect(Collectors.toMap(MerchantOrderPayment::getAtrn, Function.identity()));

        // Build Recon Map (ATRN -> List<ReconFileDitl>)
        Map<String, List<ReconFileDitl>> reconMap = new HashMap<>();
        for (ReconFileDitl recon : reconList) {
            reconMap.computeIfAbsent(recon.getAtrn(), k -> new ArrayList<>()).add(recon);
        }

        // Process Matching
        for (Map.Entry<String, List<ReconFileDitl>> entry : reconMap.entrySet()) {
            String atrn = entry.getKey();
            List<ReconFileDitl> reconRecords = entry.getValue();

            if (mopMap.containsKey(atrn)) {
                if (reconRecords.size() == 1) {
                    result.getMatchedReconRecords().addAll(reconRecords);
                } else {
                    result.getDuplicateReconRecords().addAll(reconRecords);
                }
            } else {
                result.getUnmatchedReconRecords().addAll(reconRecords);
            }
        }

        // Set counts
        result.setMatchedCount(result.getMatchedReconRecords().size());
        result.setUnmatchedCount(result.getUnmatchedReconRecords().size());
        result.setDuplicateCount(result.getDuplicateReconRecords().size());

        return result;
    }
}



public class ReconResultDTO {

    private long matchedCount;
    private long unmatchedCount;
    private long duplicateCount;

    private List<ReconFileDitl> matchedReconRecords;
    private List<ReconFileDitl> unmatchedReconRecords;
    private List<ReconFileDitl> duplicateReconRecords;

    public ReconResultDTO() {
        this.matchedReconRecords = new ArrayList<>();
        this.unmatchedReconRecords = new ArrayList<>();
        this.duplicateReconRecords = new ArrayList<>();
    }

    // Getters and Setters
}

@Repository
public interface ReconRepository extends JpaRepository<ReconFileDitl, Long> {

    @Query(value = "SELECT r.atrn, COUNT(*) as count " +
                   "FROM recon_file_ditl r " +
                   "JOIN merchant_order_payment m ON r.atrn = m.atrn " +
                   "GROUP BY r.atrn " +
                   "HAVING COUNT(*) = 1", nativeQuery = true)
    List<Object[]> findMatchedATRNs();

    @Query(value = "SELECT r.atrn, COUNT(*) as count " +
                   "FROM recon_file_ditl r " +
                   "LEFT JOIN merchant_order_payment m ON r.atrn = m.atrn " +
                   "WHERE m.atrn IS NULL " +
                   "GROUP BY r.atrn", nativeQuery = true)
    List<Object[]> findUnmatchedATRNs();

    @Query(value = "SELECT r.atrn, COUNT(*) as count " +
                   "FROM recon_file_ditl r " +
                   "JOIN merchant_order_payment m ON r.atrn = m.atrn " +
                   "GROUP BY r.atrn " +
                   "HAVING COUNT(*) > 1", nativeQuery = true)
    List<Object[]> findDuplicateATRNs();
}

@Repository
public interface MerchantOrderPaymentRepository extends JpaRepository<MerchantOrderPayment, String> {

    List<MerchantOrderPayment> findByAtrn(String atrn);
}

@Repository
public interface ReconFileDitlRepository extends JpaRepository<ReconFileDitl, Long> {

    List<ReconFileDitl> findByAtrn(String atrn);
}



@Service
public class ReconService {

    @Autowired
    private ReconRepository reconRepository;

    @Autowired
    private MerchantOrderPaymentRepository mopRepository;

    @Autowired
    private ReconFileDitlRepository reconFileDitlRepository;

    public List<ReconResponseDTO> getMatchedATRNs() {
        List<Object[]> rawData = reconRepository.findMatchedATRNs();
        return buildResponseDTOs(rawData);
    }

    public List<ReconResponseDTO> getUnmatchedATRNs() {
        List<Object[]> rawData = reconRepository.findUnmatchedATRNs();
        return buildResponseDTOs(rawData);
    }

    public List<ReconResponseDTO> getDuplicateATRNs() {
        List<Object[]> rawData = reconRepository.findDuplicateATRNs();
        return buildResponseDTOs(rawData);
    }

    private List<ReconResponseDTO> buildResponseDTOs(List<Object[]> rawData) {
        List<ReconResponseDTO> result = new ArrayList<>();

        for (Object[] row : rawData) {
            String atrn = (String) row[0];
            long count = ((BigInteger) row[1]).longValue();

            List<ReconFileDitl> reconRecords = reconFileDitlRepository.findByAtrn(atrn);
            List<MerchantOrderPayment> mopRecords = mopRepository.findByAtrn(atrn);

            result.add(new ReconResponseDTO(atrn, count, reconRecords, mopRecords));
        }

        return result;
    }
}


-+-+-+-+------&+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-++-+

31/5/25

1. 

@Entity
@Table(name = "merchant_order_payment")
public class MerchantOrderPayment {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(name = "atrn", unique = true)
    private String atrn;

    @Column(name = "merchant_id")
    private String merchantId;

    @Column(name = "transaction_amount")
    private Double transactionAmount;

    @Column(name = "transaction_date")
    private LocalDate transactionDate;

    @Column(name = "payment_mode")
    private String paymentMode;

    // Getters and Setters
}

2.

@Entity
@Table(name = "recon_file_ditl")
public class ReconFileDitl {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(name = "atrn")
    private String atrn;

    @Column(name = "transaction_amount")
    private Double transactionAmount;

    @Column(name = "transaction_date")
    private LocalDate transactionDate;

    @Column(name = "matched_status")
    private String matchedStatus;

    // Other fields as needed...

    // Getters and Setters
}

3.
public class ReconResultDTO {

    private long matchedCount;
    private long unmatchedCount;
    private long duplicateCount;

    private List<ReconFileDitl> matchedReconRecords;
    private List<ReconFileDitl> unmatchedReconRecords;
    private List<ReconFileDitl> duplicateReconRecords;

    public ReconResultDTO() {
        this.matchedReconRecords = new ArrayList<>();
        this.unmatchedReconRecords = new ArrayList<>();
        this.duplicateReconRecords = new ArrayList<>();
    }

    // Getters and Setters
}


4.

@Repository
public interface MerchantOrderPaymentRepository extends JpaRepository<MerchantOrderPayment, Long> {
}


5.

@Repository
public interface ReconRepository extends JpaRepository<ReconFileDitl, Long> {

    @Query(value = """
        SELECT r.atrn FROM recon_file_ditl r
        INNER JOIN merchant_order_payment m ON r.atrn = m.atrn
    """, nativeQuery = true)
    List<String> findMatchedATRNs();

    @Query(value = """
        SELECT r.atrn FROM recon_file_ditl r
        LEFT JOIN merchant_order_payment m ON r.atrn = m.atrn
        WHERE m.atrn IS NULL
    """, nativeQuery = true)
    List<String> findUnmatchedATRNs();

    @Query(value = """
        SELECT r.atrn FROM recon_file_ditl r
        WHERE r.atrn IN (
            SELECT atrn FROM recon_file_ditl GROUP BY atrn HAVING COUNT(*) > 1
        )
    """, nativeQuery = true)
    List<String> findDuplicateATRNs();

    @Modifying
    @Transactional
    @Query(value = "UPDATE recon_file_ditl SET matched_status = :status WHERE atrn IN (:atrns)", nativeQuery = true)
    int updateMatchedStatus(@Param("status") String status, @Param("atrns") List<String> atrns);

    List<ReconFileDitl> findByAtrnIn(List<String> atrns);
}


6.
@Service
public class ReconService {

    @Autowired
    private ReconRepository reconRepository;

    @Transactional
    public ReconResultDTO getReconSummaryAndUpdateStatus() {
        ReconResultDTO result = new ReconResultDTO();

        // 1️⃣ Matched
        List<String> matchedATRNs = reconRepository.findMatchedATRNs();
        List<ReconFileDitl> matchedRecords = matchedATRNs.isEmpty() ? List.of() : reconRepository.findByAtrnIn(matchedATRNs);
        reconRepository.updateMatchedStatus("MATCHED", matchedATRNs);
        result.setMatchedReconRecords(matchedRecords);
        result.setMatchedCount(matchedRecords.size());

        // 2️⃣ Unmatched
        List<String> unmatchedATRNs = reconRepository.findUnmatchedATRNs();
        List<ReconFileDitl> unmatchedRecords = unmatchedATRNs.isEmpty() ? List.of() : reconRepository.findByAtrnIn(unmatchedATRNs);
        reconRepository.updateMatchedStatus("UNMATCHED", unmatchedATRNs);
        result.setUnmatchedReconRecords(unmatchedRecords);
        result.setUnmatchedCount(unmatchedRecords.size());

        // 3️⃣ Duplicate
        List<String> duplicateATRNs = reconRepository.findDuplicateATRNs();
        List<ReconFileDitl> duplicateRecords = duplicateATRNs.isEmpty() ? List.of() : reconRepository.findByAtrnIn(duplicateATRNs);
        reconRepository.updateMatchedStatus("DUPLICATE", duplicateATRNs);
        result.setDuplicateReconRecords(duplicateRecords);
        result.setDuplicateCount(duplicateRecords.size());

        return result;
    }
}

7.
@RestController
@RequestMapping("/api/recon")
public class ReconController {

    @Autowired
    private ReconService reconService;

    @GetMapping("/summary")
    public ResponseEntity<ReconResultDTO> getReconSummary() {
        ReconResultDTO result = reconService.getReconSummaryAndUpdateStatus();
        return ResponseEntity.ok(result);
    }
}

8.