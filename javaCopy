@Service
@RequiredArgsConstructor
public class JavaReconciliationService {

    private static final int BATCH_SIZE = 20000;
    private final LoggerUtility log = LoggerFactoryUtility.getLogger(this.getClass());
    private final MerchantOrderPaymentDao merchantOrderPaymentDao;
    private final ReconFileDtlsDao reconFileDtlsDao;
    private final ReconFileSummaryDao reconFileSummaryDao;
    private final ReconResultProcessorService reconResultProcessorService;

    public void performRecon(UUID rfsId) {
        ReconFileSummaryDto reconFileSummaryDto= reconFileSummaryDao.findByFileSummaryId(rfsId);
        log.info("Starting Recon file process at: {}", System.currentTimeMillis());
        try {
            // Step 1. Process Reconciliation to get Matched , Unmatched and Duplicate record.
            ReconResultDto reconResultDto = processReconciliation(rfsId);
            // Step 2. Update ReconStatus in ReconFileDtls Table
            updateReconStatuses(reconResultDto);
            // Step 3. Update Matched , Unmatched and Duplicate count in ReconFileSummary table
            updateReconSummaryCount(reconFileSummaryDto, reconResultDto);
            log.info("Recon file process completed at: {}", System.currentTimeMillis());
            log.info("Publishing Recon result for Transaction Service");
            // Step 4. Publish Matched record to Transaction Service
            reconResultProcessorService.reconStatusPublisher(reconResultDto);
        } catch (Exception ex) {
            log.error("Error during recon process for rfsId {}: {}", rfsId, ex.getMessage(), ex);
            reconFileSummaryDto.setReconStatus(Status.FAIL);
            reconFileSummaryDao.save(reconFileSummaryDto);
        }
    }

    private ReconResultDto processReconciliation(UUID rfsId) {

        Map<String, List<ReconFileDtlsDto>> reconPaymentMap = fetchAndGroupReconData(rfsId);
        Map<String, MerchantOrderPaymentDto> systemPaymentMap = fetchMerchantPayments(rfsId);

        return categorizeRecords(reconPaymentMap, systemPaymentMap);
    }

    private Map<String, List<ReconFileDtlsDto>> fetchAndGroupReconData(UUID rfsId) {
        log.info("Fetching Recon data from ReconFileDtls");
        List<ReconFileDtlsDto> reconFileData = reconFileDtlsDao.getAllReconFileData(rfsId);
        return reconFileData.stream().collect(Collectors.groupingBy(ReconFileDtlsDto::getAtrnNum));
    }

    private Map<String, MerchantOrderPaymentDto> fetchMerchantPayments(UUID rfsId) {
        log.info("Fetching matched ATRNs data from MerchantOrderPayment");
        List<MerchantOrderPaymentDto> payments = merchantOrderPaymentDao.getMatchedData(rfsId);
        return payments.stream().collect(Collectors.toMap(MerchantOrderPaymentDto::getAtrnNum, Function.identity(), (existing, replacement) -> {
            log.warn("Duplicate ATRN detected: {}", existing.getAtrnNum());
            return existing;
        }));
    }

    private ReconResultDto categorizeRecords(Map<String, List<ReconFileDtlsDto>> reconPaymentMap, Map<String, MerchantOrderPaymentDto> systemPaymentMap) {

        ReconResultDto result = new ReconResultDto();

        reconPaymentMap.forEach((atrn, reconList) -> {

            if (systemPaymentMap.containsKey((atrn))) {
                processMatchingAtrn(reconList, systemPaymentMap.get(atrn), result);
            } else {
                result.addUnmatched(reconList);
            }

        });

        return result;
    }

    private void processMatchingAtrn(List<ReconFileDtlsDto> reconFileDtlsList, MerchantOrderPaymentDto payment, ReconResultDto result) {

        //Step-1 Duplicate checking
        if (reconFileDtlsList.size() > 1) {

            boolean oneMatched = false;

            for (ReconFileDtlsDto rfd : reconFileDtlsList) {

                if (!oneMatched && rfd.getPaymentAmount().compareTo(payment.getDebitAmt()) == 0) {
                    result.addMatched(rfd);
                    oneMatched = true;
                } else {
                    result.addDuplicate(rfd);
                }
            }

            //Step-2 Single record checking
        } else if (reconFileDtlsList.size() == 1) {

            if (reconFileDtlsList.getFirst().getPaymentAmount().compareTo(payment.getDebitAmt()) == 0) {
                result.addMatched(reconFileDtlsList.getFirst());
            } else {
                result.addUnmatched(reconFileDtlsList);
            }

        } else {
            log.error("Invalid reconFileDtlsList: {} with blank size.", reconFileDtlsList);
        }

    }

    private void updateReconStatuses(ReconResultDto result) {
        batchUpdateStatus(result.getMatched(), "MATCHED");
        batchUpdateStatus(result.getUnmatched(), "UNMATCHED");
        batchUpdateStatus(result.getDuplicate(), "DUPLICATE");
    }



    /**
     * * Updating Recon Status in batch.
     * *
     * * @param list   of ReconFileDtls
     * * @param status Recon_Status
     */
    // Batch to update Status
    @Transactional
    private void batchUpdateStatus(List<ReconFileDtlsDto> list, String status) {
        final int batchSize = BATCH_SIZE;
        for (int i = 0; i < list.size(); i += batchSize) {
            int end = Math.min(i + batchSize, list.size());
            List<String> batchAtrns = list.subList(i, end).stream().map(ReconFileDtlsDto::getAtrnNum).collect(Collectors.toList());
            reconFileDtlsDao.updateReconStatus(status, batchAtrns);
        }
    }

    private void updateReconSummaryCount(ReconFileSummaryDto reconFileSummaryDto, ReconResultDto reconResultDto) {
        reconFileSummaryDto.setMatchedRecords(reconResultDto.getMatched().size());
        reconFileSummaryDto.setUnmatchedRecords(reconResultDto.getUnmatched().size());
        reconFileSummaryDto.setDuplicateRecords(reconResultDto.getDuplicate().size());
        reconFileSummaryDao.save(reconFileSummaryDto);
    }
}


@Component
@RequiredArgsConstructor
public class ReconFileDtlsDao {

    private final LoggerUtility log = LoggerFactoryUtility.getLogger(this.getClass());
    private final ReconFileDtlsRepository reconFileDtlsRepository;
    private final ReconFileDtlsMapper reconFileDtlsMapper;
    private final ReconFileRepository fileDtlsRepository;

    public void save(List<ReconFileDtlsDto> reconFileDtlsDtoList) {

        reconFileDtlsRepository.saveAll(reconFileDtlsMapper.mapToEntityList(reconFileDtlsDtoList));
    }

    /**
     * This will update the ReconStatus
     * @param status String
     * @param atrnNums List of atrn
     */
    @Transactional
    public void updateReconStatus(String status, List<String> atrnNums) {
        fileDtlsRepository.updateReconStatus(status,atrnNums);
    }

    public List<ReconFileDtlsDto> getAllReconFileData(UUID rfsId){
         return reconFileDtlsMapper.mapToDtoList(fileDtlsRepository.getAllByRfsId(rfsId));
    }

    public List<ReconStatusCountProjection> getReconStatusCount(UUID rfdId) {
        return reconFileDtlsRepository.findReconStatusCountByRfsId(rfdId);
    }

    public List<ReconFileDtlsDto> getReconFileDataByRfsIdAndReconStatus(UUID rfsId, String reconStatus){
        return reconFileDtlsMapper.mapToDtoList(reconFileDtlsRepository.findByRfsIdAndReconStatus(rfsId, reconStatus));
    }
}

@Repository
@RequiredArgsConstructor
public class ReconFileRepository {

    private final NamedParameterJdbcTemplate jdbcTemplate;
    private final LoggerUtility log = LoggerFactoryUtility.getLogger(this.getClass());

    /**
     * This will update the ReconStatus
     *
     * @param status   String
     * @param atrnNums List of atrn
     */
    @Transactional
    public void updateReconStatus(String status, List<String> atrnNums) {

        log.info("Updating {} status.", status);
        MapSqlParameterSource[] batchParams = atrnNums.stream().map(atrn -> new MapSqlParameterSource().addValue("status", status).addValue("atrnNum", atrn)).toArray(MapSqlParameterSource[]::new);

        jdbcTemplate.batchUpdate(UPDATE_RECON_STATUS, batchParams);
    }

@UtilityClass
public class JdbcQuery {


public static final String UPDATE_RECON_STATUS="""
                UPDATE RECON_FILE_DTLS rfd
                SET rfd.RECON_STATUS = :status
                WHERE rfd.ATRN_NUM = :atrnNum
                """;
}

@Data
@Builder
@AllArgsConstructor
@NoArgsConstructor
public class ReconFileDtlsDto {

    private UUID rfdId;
    private UUID rfsId;
    private int rowNumber;
    private String recordType;
    private String atrnNum;
    private BigDecimal paymentAmount;
    private Date paymentDate;
    private String bankRefNumber;
    private String paymentStatus;
    private String reconStatus;
    private String settlementStatus;
    private String remark;

    /**
     * @return String in-format of [atrnNum]:[bankRefNumber]
     */
    public String getAtrnDtls() {
        return String.format("%s:%s:%s", getAtrnNum(), getBankRefNumber(),getRfsId());
    }

}
