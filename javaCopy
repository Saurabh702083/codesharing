Below is my code can you please check method names, classes as per requriment and code as per pro stander and make class and method as per good practice in java  

@RestController
@RequiredArgsConstructor
@RequestMapping("/gst/invoice")
public class gstInvoiceDownloadController {
    private final LoggerUtility logger = LoggerFactoryUtility.getLogger(this.getClass());
    private final GstInvoiceDownloadService gstInvoiceDownloadService;

    @PostMapping("/download")
    public CommunicationResponse<String> gstInvoiceDownload(@RequestBody GstInvoiceRequest gstInvoiceRequest){
        logger.info("Request to get gst invoice from SFTP to s3.");
       return gstInvoiceDownloadService.downloadGstInvoice(gstInvoiceRequest);
    }

}
---------------

/**
 * Class Name: GstInvoiceRequestService
 * Description: This class will help in getting file from sftp and uploading on s3.
 * Author: Saurabh mahto
 * <p>
 * Copyright (c) 2025 [State Bank of India]
 * All rights reserved
 * Version: 1.0
 */
@Service
@RequiredArgsConstructor
public class GstInvoiceDownloadService {
    private final LoggerUtility logger = LoggerFactoryUtility.getLogger(this.getClass());
    private final SftpClientService sftpClientService;
    private final GstInvoiceDownloadProducer gstInvoiceDownloadProducer;
    private final ObjectMapper objectMapper;
    private final FileService fileService;
    private final GstInvoiceValidation gstInvoiceValidation;
    private final ExecutorService virtualThreadExecutor;
    private final Semaphore semaphore = new Semaphore(MAX_CONCURRENT_UPLOADS);

    /**
     * Processes the invoice request and uploads the relevant PDF files to S3.
     *
     * @param gstInvoiceRequest the GST invoice request
     * @return a communication response indicating the status of the operation
     */
    public CommunicationResponse<String> downloadGstInvoice(GstInvoiceRequest gstInvoiceRequest) {
        gstInvoiceValidation.validateGstInvoiceRequest(gstInvoiceRequest);
        GstInvoiceType type = GstInvoiceType.valueOf(gstInvoiceRequest.getInvoiceType());
        logger.info("Generate invoice for invoiceType:{}", gstInvoiceRequest.getInvoiceType());
        boolean hasGstn = !CollectionUtils.isEmpty(gstInvoiceRequest.getGstns());
        logger.info("Processing invoices for monthYear={}, type={}, gstIns={}", gstInvoiceRequest.getMonthYear(), type, gstInvoiceRequest.getGstns());
        getAndProcessZipFile(gstInvoiceRequest.getMonthYear(),gstInvoiceRequest.getGstns(),hasGstn,type);
        return CommunicationResponse.<String>builder().data(List.of("Invoice has been successfully sent")).status(RESPONSE_SUCCESS).build();

    }



    private void getAndProcessZipFile(String monthYear, List<String> gstn, boolean hasGstIn, GstInvoiceType invoiceType){
        InputStream zipStream =  sftpClientService.getMonthlyZip(monthYear);
        ZipInputStream zis = new ZipInputStream(zipStream);
        processZipEntries(zis, invoiceType, gstn, hasGstIn,monthYear);
    }

    /**
     * Processes the ZIP entries and uploads the relevant PDF files to S3.
     *
     * @param zis      the ZIP input stream
     * @param type     the invoice type
     * @param gstns   the list of GSTNs
     * @param hasGstin whether the GSTN list is not empty
     */
    private void processZipEntries(ZipInputStream zis, GstInvoiceType type, List<String> gstns, boolean hasGstin, String monthYear)  {
        try {
            ZipEntry entry;
            while ((entry = zis.getNextEntry()) != null) {
                if (isEntryNotPdf(entry) || isEntryDirectory(entry)) {
                    continue;
                }
                ParsedInvoiceFile parsedInvoiceFile = InvoiceFileParser.parse(entry.getName(), monthYear);
                if(parsedInvoiceFile==null){
                    logger.warn("Skipping invalid invoice file: {}", entry.getName());
                    zis.closeEntry();
                    continue;
                }
                logger.info("Processing invoice upload for fileName : {}, InvoiceType : {}, GstIn : {}", parsedInvoiceFile.getFileName(), parsedInvoiceFile.getInvoiceType(), parsedInvoiceFile.getPartyGstIn());
                if (!isEntryTypeMatching(parsedInvoiceFile.getInvoiceType(), type, hasGstin) || !isGstnValid(parsedInvoiceFile.getPartyGstIn(), gstns, hasGstin)) {
                    continue;
                }
                logger.info("Uploading gstIn invoice to s3 for gstIn :{}", parsedInvoiceFile.getPartyGstIn());
                byte[] pdfBytes = ZipFileReader.readZipInputStream(zis);
                virtualThreadExecutor.submit(() -> executeWithSemaphore(parsedInvoiceFile, pdfBytes));
                zis.closeEntry();
            }
        }catch (Exception ex) {
            throw new CommunicationException(ZIP_FILE_ERROR_CODE, MessageFormat.format(ZIP_FILE_ERROR_MESSAGE , ex.getMessage()));
        }

    }


    private void executeWithSemaphore(ParsedInvoiceFile parsed, byte[] pdfBytes) {
        try {
            semaphore.acquire();
            uploadWithRetry(parsed, pdfBytes);
        } catch (InterruptedException ex) {
            Thread.currentThread().interrupt();
        } finally {
            semaphore.release();
        }
    }

    private void uploadWithRetry(ParsedInvoiceFile parsed, byte[] pdfBytes) {
        for (int attempt = 1; attempt <= MAX_RETRIES; attempt++) {
            try {
                String s3Path = fileService.uploadFile(parsed.getFileName(), pdfBytes);
                publishInvoice(parsed, s3Path);
                return;

            } catch (Exception ex) {
                logger.error("Upload attempt {} failed for file {}", attempt, parsed.getFileName(), ex.getMessage());

                if (attempt == MAX_RETRIES) {
                    logger.error("Max retries exceeded for file {}", parsed.getFileName());
                }
            }
        }
    }

    /**
     * Method to publish s3 path of invoice to report service
     * @param parsedInvoiceFile ParsedInvoiceFile
     * @param s3Path String
     */
    private void publishInvoice (ParsedInvoiceFile parsedInvoiceFile, String s3Path ){
        S3UploadInvoiceResponse s3UploadInvoiceResponse= S3UploadInvoiceResponse.builder().invoiceType(parsedInvoiceFile.getInvoiceType())
                .gstIn(parsedInvoiceFile.getPartyGstIn()).monthYear(parsedInvoiceFile.getMonthYear())
                .s3Key(s3Path).build();
        try {
            String uploadInvoiceMessage = objectMapper.writeValueAsString(s3UploadInvoiceResponse);
            gstInvoiceDownloadProducer.publish(parsedInvoiceFile.getInvoiceType()+"_"+UUID.randomUUID(),uploadInvoiceMessage);
            logger.info("Successfully send the s3 path to report service");
        }catch (Exception ex){
            logger.error("Error in publishing alert", ex);
        }
    }



    private boolean isEntryNotPdf(ZipEntry entry) {
        return !entry.getName().toLowerCase().endsWith(".pdf");
    }

    private boolean isEntryDirectory(ZipEntry entry) {
        return entry.isDirectory();
    }

    private boolean isEntryTypeMatching(GstInvoiceType entryType, GstInvoiceType type, boolean hasGstin) {
        return !hasGstin || entryType == type;
    }

    private boolean isGstnValid(String gstinFromFile, List<String> gstins, boolean hasGstin) {
        return !hasGstin || (StringUtils.hasText(gstinFromFile) && gstins.contains(gstinFromFile));
    }
}

/**
 * Class Name: GstInvoiceRequestValidation
 * *
 * Description: Validates gst invoice request..
 * *
 * Author: Saurabh mahto
 * Copyright (c) 202s [State Bank of India]
 * All rights reserved
 * *
 * Version:1.0
 */
@Component
@RequiredArgsConstructor
public class GstInvoiceValidation extends BaseValidator{

    private static final DateTimeFormatter MONTH_YEAR_FORMATTER = DateTimeFormatter.ofPattern(MONTH_YEAR_FORMAT);
    private final CommunicationConfig config;

    public void validateGstInvoiceRequest(GstInvoiceRequest gstInvoiceRequest){
        errorDtoList = new ArrayList<>();
        validateMandatoryFields(gstInvoiceRequest);
        validateLeadingTrailingSpaces(gstInvoiceRequest);
        validateFields(gstInvoiceRequest);
    }

    private void validateMandatoryFields(GstInvoiceRequest gstInvoiceRequest){
        checkMandatoryField(gstInvoiceRequest.getMonthYear(), MONTH_YEAR);
        throwIfErrors();
    }

    private void validateLeadingTrailingSpaces(GstInvoiceRequest gstInvoiceRequest){
        checkForLeadingTrailingAndSingleSpace(gstInvoiceRequest.getMonthYear(), MONTH_YEAR);
        checkForLeadingTrailingAndSingleSpace(gstInvoiceRequest.getInvoiceType(), INVOICE_TYPE);
        throwIfErrors();
    }

    private void validateFields(GstInvoiceRequest gstInvoiceRequest){
        validateMonthYear(gstInvoiceRequest.getMonthYear());
        validateFieldValue(gstInvoiceRequest.getInvoiceType(), Arrays.stream(GstInvoiceType.values()).map(Enum::name).toList(), INVOICE_TYPE);
        validateMaxGstnList(gstInvoiceRequest.getGstns());
        throwIfErrors();
    }


    private void validateMonthYear(String monthYear) {
        try {
            YearMonth.parse(monthYear, MONTH_YEAR_FORMATTER);
        } catch (DateTimeException e) {
            throw new ValidationException(INVALID_ERROR_CODE_NO_REASON, MessageFormat.format(INVALID_ERROR_MESSAGE,MONTH_YEAR ,"Expected YYYYMM"));
        }
    }

    private void validateMaxGstnList(List<String> gstns){
        if(config.getMaxGstnAllowed() >gstns.size()){
            throw new ValidationException(MAX_GST_ALLOWED_ERROR_CODE,MessageFormat.format(MAX_GSTN_CAN_BE_PROCCESSED_AT_A_TIME,config.getMaxGstnAllowed()));
        }
    }

}



@Service
@RequiredArgsConstructor
public class SftpClientService {

    private final LoggerUtility logger = LoggerFactoryUtility.getLogger(this.getClass());
    private final CachingSessionFactory<DirEntry> cachingSessionFactory;

    @Value("${sftp.gstIn.baseDir}")
    private String GST_INVOICE_BASE_DIR;


    public InputStream getMonthlyZip(String monthYear) {
        try {
            Path zipPath = Path.of(GST_INVOICE_BASE_DIR, "EPY_INVOICES_"+monthYear + ".zip");
            logger.info("Reading local zip file: {}", zipPath.toAbsolutePath());
            if (!Files.exists(zipPath)) {
                throw new CommunicationException(SFTP_ERROR_CODE, MessageFormat.format(SFTP_ERROR_MESSAGE,"Error while finding zip file for monthYear: " + monthYear,FILE_NOT_FOUND_ERROR_CODE, FILE_NOT_FOUND));
            }
            return new FileInputStream(zipPath.toFile());
        } catch (FileNotFoundException e) {
            throw new CommunicationException(SFTP_ERROR_CODE, MessageFormat.format(SFTP_ERROR_MESSAGE,"Error opening local zip file for monthYear: " + monthYear, e.getMessage()));
        }
    }
}
-------

public class InvoiceFileParser {


    public static ParsedInvoiceFile parse(String filePath, String monthYear) {
        try {
            String fileName = filePath.replace("EPY_INVOICES_" + monthYear + "/", "");
            if (!fileName.startsWith("Invoice-") || !fileName.endsWith(".pdf")) {
                return null;
            }
            String withoutExt = fileName.substring(0, fileName.length() - 4);
            String[] parts = withoutExt.split("-");
            String sbiGstIn = parts[1];
            String typeIndicator = parts[2];
            String yearMonth = parts[3] + "-" + parts[4];
            String partyGstIn = parts[5];
            String invoiceRef = parts[7];

            GstInvoiceType fileType = typeIndicator.equals("0") ? GstInvoiceType.CUSTOMER_GST_INVOICE : GstInvoiceType.MERCHANT_GST_INVOICE;

            return ParsedInvoiceFile.builder().invoiceType(fileType).sbiGstIn(sbiGstIn).partyGstIn(partyGstIn).invoiceReference(invoiceRef).monthYear(yearMonth).fileName(fileName).build();
        } catch (Exception ex){
            return null;
        }
    }
}

@Component
@RequiredArgsConstructor
public class ZipFileReader {

    public static byte[] readZipInputStream (ZipInputStream zis) throws Exception {
        ByteArrayOutputStream buffer = new ByteArrayOutputStream();
        byte[] tmp = new byte[4096];
        int read;
        while ((read = zis.read(tmp)) != -1) {
            buffer.write(tmp, 0, read);
        }
        return buffer.toByteArray();
    }

}
