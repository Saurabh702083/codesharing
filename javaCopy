  @Service
@RequiredArgsConstructor
public class DataSyncService {

    private final LoggerUtility log = LoggerFactoryUtility.getLogger(this.getClass());

    private final MerchantOrderPaymentMapper paymentMapper;
    private final OrderMapper orderMapper;
    private final ReconStatusUpdatePublisher reconStatusUpdateProducer;
    private final MerchantOrderDao merchantOrderDao;
    private final MerchantOrderPaymentDao merchantOrderPaymentDao;

    @Value("${spring.jpa.properties.hibernate.jdbc.batch_size}")
    private int batchSize;

    /**
     * Syncing of data from view tables to Operation DB by Schedular and publishing the ATRN to
     * the Transaction service for updating its status
     */
    public void syncTransactionData() {
        //Step 1. Syncing Data from OrderReconView to MerchantOrder Table
        log.info("Syncing data to MerchantOrder table at : {}", System.currentTimeMillis());
        syncOrderData();
        //Step 2. Syncing Data from PaymentReconView to MerchantOrderPayment Table.
        log.info("Syncing data to MerchantOrderPayment table at : {}", System.currentTimeMillis());
        List<PaymentReconView> paymentReconViews = syncPaymentData();
        //Step 3. Kafka producer for updating Transaction status
        log.info("Kafka producer for updating Status  ");
        statusProducer(paymentReconViews);
    }

    /**
     * Syncing or data from OrderReconView to MerchantOrder Table
     */
    @Transactional
    public void syncOrderData() {

        log.info("Getting data from merchant order View ");
        List<OrderReconView> allOrderViewData = merchantOrderDao.getAllOrderViewData();
        List<Order> orders = orderMapper.toOrderList(allOrderViewData);
        log.info("updating the Merchant order table");
        merchantOrderDao.updateMerchantOrder(orders);
    }

    /**
     * Syncing or data from OrderPaymentReconView to MerchantOrderPayment  Table
     *
     * @return List of PaymentReconView
     */
    @Transactional
    public List<PaymentReconView> syncPaymentData() {
        log.info("Getting data from merchant order payment View ");
        List<PaymentReconView> allPaymentViewData = merchantOrderPaymentDao.getAllPaymentViewData();
        List<MerchantOrderPayment> merchantPayments = paymentMapper.toPaymentList(allPaymentViewData);
        log.info("updating the Merchant order payment table ");
        merchantOrderPaymentDao.updateOrderPayment(merchantPayments);
        return allPaymentViewData;
    }

    /**
     * Publishing ATRN to Transaction service by Kafka
     *
     * @param paymentReconViews List of PaymentReconView
     */
    public void statusProducer(List<PaymentReconView> paymentReconViews) {
        log.info("Publishing the ATRN ");
        paymentReconViews.forEach(paymentReconView -> {
            String atrnNumber = paymentReconView.getAtrnNum();
            SettlementStatusDto settlementStatusDto = SettlementStatusDto.builder().status(SETTLED).atrn(atrnNumber).build();
            reconStatusUpdateProducer.publish(UPDATE_STATUS, atrnNumber, settlementStatusDto);
        });
        log.info("Finished pushing ATRN to Transaction service");
    }
}

@ExtendWith(MockitoExtension.class)
class DataSyncServiceTest {

    @Mock
    private MerchantOrderPaymentMapper paymentMapper;

    @Mock
    private OrderMapper orderMapper;

    @Mock
    private ReconStatusUpdatePublisher reconStatusUpdateProducer;

    @Mock
    private MerchantOrderDao merchantOrderDao;

    @Mock
    private MerchantOrderPaymentDao merchantOrderPaymentDao;

    @InjectMocks
    private DataSyncService dataSyncService;


    @Test
    void syncTransactionDataTest() {
        List<PaymentReconView> allPaymentViewDataList = new ArrayList<>();
        PaymentReconView paymentReconView = PaymentReconView.builder().atrnNum("ATRN123").build();
        allPaymentViewDataList.add(paymentReconView);

        List<MerchantOrderPayment> merchantPaymentsList = new ArrayList<>();
        MerchantOrderPayment merchantOrderPayment = new MerchantOrderPayment();
        merchantOrderPayment.setAtrnNum("ATRN123");
        merchantPaymentsList.add(merchantOrderPayment);


        when(merchantOrderPaymentDao.getAllPaymentViewData()).thenReturn(allPaymentViewDataList);
        when(spy(paymentMapper.toPaymentList(allPaymentViewDataList))).thenReturn(merchantPaymentsList);
        doNothing().when(merchantOrderPaymentDao).updateOrderPayment(merchantPaymentsList);
        dataSyncService.syncTransactionData();
        verify(merchantOrderPaymentDao, times(1)).updateOrderPayment(merchantPaymentsList);

    }


}
-------------------------------------

Above is my service class and its test case in junit 5.

now i want to write test case for my other service in  similar way i worte it above .

so below is my service class for which i want to write test casse in junit 5


@Service
@RequiredArgsConstructor
public class JavaReconciliationService {

    private static final int BATCH_SIZE = 20000;
    private final LoggerUtility log = LoggerFactoryUtility.getLogger(this.getClass());
    private final MerchantOrderPaymentDao merchantOrderPaymentDao;
    private final ReconFileDtlsDao reconFileDtlsDao;
    private final ReconFileSummaryDao reconFileSummaryDao;
    private final ReconResultProcessorService reconResultProcessorService;

    public void performRecon(UUID rfsId) {
        ReconFileSummaryDto reconFileSummaryDto= reconFileSummaryDao.findByFileSummaryId(rfsId);
        log.info("Starting Recon file process at: {}", System.currentTimeMillis());
        try {
            // Step 1. Process Reconciliation to get Matched , Unmatched and Duplicate record.
            ReconResultDto reconResultDto = processReconciliation(rfsId);
            // Step 2. Update ReconStatus in ReconFileDtls Table
            updateReconStatuses(reconResultDto);
            // Step 3. Update Matched , Unmatched and Duplicate count in ReconFileSummary table
            updateReconSummaryCount(reconFileSummaryDto, reconResultDto);
            log.info("Recon file process completed at: {}", System.currentTimeMillis());
            log.info("Publishing Recon result for Transaction Service");
            // Step 4. Publish Matched record to Transaction Service
            reconResultProcessorService.reconStatusPublisher(reconResultDto);
        } catch (Exception ex) {
            log.error("Error during recon process for rfsId {}: {}", rfsId, ex.getMessage(), ex);
            reconFileSummaryDto.setReconStatus(Status.FAIL);
            reconFileSummaryDao.save(reconFileSummaryDto);
        }
    }

    private ReconResultDto processReconciliation(UUID rfsId) {

        Map<String, List<ReconFileDtlsDto>> reconPaymentMap = fetchAndGroupReconData(rfsId);
        Map<String, MerchantOrderPaymentDto> systemPaymentMap = fetchMerchantPayments(rfsId);

        return categorizeRecords(reconPaymentMap, systemPaymentMap);
    }

    private Map<String, List<ReconFileDtlsDto>> fetchAndGroupReconData(UUID rfsId) {
        log.info("Fetching Recon data from ReconFileDtls");
        List<ReconFileDtlsDto> reconFileData = reconFileDtlsDao.getAllReconFileData(rfsId);
        return reconFileData.stream().collect(Collectors.groupingBy(ReconFileDtlsDto::getAtrnNum));
    }

    private Map<String, MerchantOrderPaymentDto> fetchMerchantPayments(UUID rfsId) {
        log.info("Fetching matched ATRNs data from MerchantOrderPayment");
        List<MerchantOrderPaymentDto> payments = merchantOrderPaymentDao.getMatchedData(rfsId);
        return payments.stream().collect(Collectors.toMap(MerchantOrderPaymentDto::getAtrnNum, Function.identity(), (existing, replacement) -> {
            log.warn("Duplicate ATRN detected: {}", existing.getAtrnNum());
            return existing;
        }));
    }

    private ReconResultDto categorizeRecords(Map<String, List<ReconFileDtlsDto>> reconPaymentMap, Map<String, MerchantOrderPaymentDto> systemPaymentMap) {

        ReconResultDto result = new ReconResultDto();

        reconPaymentMap.forEach((atrn, reconList) -> {

            if (systemPaymentMap.containsKey((atrn))) {
                processMatchingAtrn(reconList, systemPaymentMap.get(atrn), result);
            } else {
                result.addUnmatched(reconList);
            }

        });

        return result;
    }

    private void processMatchingAtrn(List<ReconFileDtlsDto> reconFileDtlsList, MerchantOrderPaymentDto payment, ReconResultDto result) {

        //Step-1 Duplicate checking
        if (reconFileDtlsList.size() > 1) {

            boolean oneMatched = false;

            for (ReconFileDtlsDto rfd : reconFileDtlsList) {

                if (!oneMatched && rfd.getPaymentAmount().compareTo(payment.getDebitAmt()) == 0) {
                    result.addMatched(rfd);
                    oneMatched = true;
                } else {
                    result.addDuplicate(rfd);
                }
            }

            //Step-2 Single record checking
        } else if (reconFileDtlsList.size() == 1) {

            if (reconFileDtlsList.getFirst().getPaymentAmount().compareTo(payment.getDebitAmt()) == 0) {
                result.addMatched(reconFileDtlsList.getFirst());
            } else {
                result.addUnmatched(reconFileDtlsList);
            }

        } else {
            log.error("Invalid reconFileDtlsList: {} with blank size.", reconFileDtlsList);
        }

    }

    private void updateReconStatuses(ReconResultDto result) {
        batchUpdateStatus(result.getMatched(), "MATCHED");
        batchUpdateStatus(result.getUnmatched(), "UNMATCHED");
        batchUpdateStatus(result.getDuplicate(), "DUPLICATE");
    }

    @Transactional
    private void batchUpdateStatus(List<ReconFileDtlsDto> list, String status) {
        final int batchSize = BATCH_SIZE;
        for (int i = 0; i < list.size(); i += batchSize) {
            int end = Math.min(i + batchSize, list.size());
            List<String> batchAtrns = list.subList(i, end).stream().map(ReconFileDtlsDto::getAtrnNum).collect(Collectors.toList());
            reconFileDtlsDao.updateReconStatus(status, batchAtrns);
        }
    }

    private void updateReconSummaryCount(ReconFileSummaryDto reconFileSummaryDto, ReconResultDto reconResultDto) {
        reconFileSummaryDto.setMatchedRecords(reconResultDto.getMatched().size());
        reconFileSummaryDto.setUnmatchedRecords(reconResultDto.getUnmatched().size());
        reconFileSummaryDto.setDuplicateRecords(reconResultDto.getDuplicate().size());
        reconFileSummaryDao.save(reconFileSummaryDto);
    }
}

@Data
@Builder
@AllArgsConstructor
@NoArgsConstructor
public class ReconFileSummaryDto {

    private UUID rfsId;
    private UUID rfcId;
    private String sftpPath;
    private String s3Path;
    private String fileName;
    private String bankCode;
    private Long fileReceivedTime;
    private Long fileUploadTime;
    private BigDecimal totalAmount;
    private Status parsingStatus;
    private Integer totalRecords;
    private Integer passedRecords;
    private Integer failedRecords;
    private Status reconStatus;
    private Long reconTime;
    private Status settlementStatus;
    private Long settlementTime;
    private String remark;
    private Status fileUploadStatus;
    private Integer matchedRecords;
    private Integer unmatchedRecords;
    private Integer duplicateRecords;
}

@Getter
public  class ReconResultDto {
    private final List<ReconFileDtlsDto> matched = new LinkedList<>();
    private final List<ReconFileDtlsDto> duplicate = new LinkedList<>();
    private final List<ReconFileDtlsDto> unmatched = new LinkedList<>();

    public void addMatched(ReconFileDtlsDto record) {
        matched.add(record);
    }

    public void addUnmatched(List<ReconFileDtlsDto> records) {
        unmatched.addAll(records);
    }

    public void removeDuplicates(List<ReconFileDtlsDto> records) {
        duplicate.removeAll(records);
    }

    public void addDuplicate(ReconFileDtlsDto record){
        duplicate.add(record);
    }
}

@Data
@Builder
@AllArgsConstructor
@NoArgsConstructor
public class ReconFileDtlsDto {

    private UUID rfdId;
    private UUID rfsId;
    private int rowNumber;
    private String recordType;
    private String atrnNum;
    private BigDecimal paymentAmount;
    private Date paymentDate;
    private String bankRefNumber;
    private String paymentStatus;
    private String reconStatus;
    private String settlementStatus;
    private String remark;

    public String getAtrnDtls(){
        return getAtrnNum()+":"+getBankRefNumber();
    }

}

@Data
@AllArgsConstructor
@NoArgsConstructor
public class MerchantOrderPaymentDto implements Serializable {

    private String mId;
    private String orderRefNumber;
    private String sbiOrderRefNumber;
    private String atrnNum;
    private BigDecimal debitAmt;
    private BigDecimal orderAmount;
    private PaymentStatus paymentStatus;
    private TransactionStatus transactionStatus;
    private Date paymentSuccessDate;
}

------++++++----
@ExtendWith(MockitoExtension.class)
class JavaReconciliationServiceTest {

    @Mock
    private MerchantOrderPaymentDao merchantOrderPaymentDao;

    @Mock
    private ReconFileDtlsDao reconFileDtlsDao;

    @Mock
    private ReconFileSummaryDao reconFileSummaryDao;

    @Mock
    private ReconResultProcessorService reconResultProcessorService;

    @InjectMocks
    private JavaReconciliationService reconciliationService;

    @Test
    void performRecon_shouldProcessMatchedAndUnmatchedAndDuplicateRecords() {
        UUID rfsId = UUID.randomUUID();

        // Prepare dummy ReconFileSummaryDto
        ReconFileSummaryDto fileSummary = new ReconFileSummaryDto();
        fileSummary.setRfsId(rfsId);
        fileSummary.setReconStatus(Status.PENDING);

        // Prepare Recon data
        ReconFileDtlsDto matchedDto = ReconFileDtlsDto.builder()
                .atrnNum("ATRN001")
                .paymentAmount(new BigDecimal("100.00"))
                .build();

        ReconFileDtlsDto unmatchedDto = ReconFileDtlsDto.builder()
                .atrnNum("ATRN002")
                .paymentAmount(new BigDecimal("150.00"))
                .build();

        ReconFileDtlsDto duplicateDto1 = ReconFileDtlsDto.builder()
                .atrnNum("ATRN003")
                .paymentAmount(new BigDecimal("200.00"))
                .build();

        ReconFileDtlsDto duplicateDto2 = ReconFileDtlsDto.builder()
                .atrnNum("ATRN003")
                .paymentAmount(new BigDecimal("250.00"))
                .build();

        // All records from ReconFileDtls
        List<ReconFileDtlsDto> reconList = List.of(matchedDto, unmatchedDto, duplicateDto1, duplicateDto2);

        // System payment records
        MerchantOrderPaymentDto matchedPayment = new MerchantOrderPaymentDto();
        matchedPayment.setAtrnNum("ATRN001");
        matchedPayment.setDebitAmt(new BigDecimal("100.00"));

        MerchantOrderPaymentDto duplicatePayment = new MerchantOrderPaymentDto();
        duplicatePayment.setAtrnNum("ATRN003");
        duplicatePayment.setDebitAmt(new BigDecimal("200.00"));

        List<MerchantOrderPaymentDto> paymentList = List.of(matchedPayment, duplicatePayment);

        // Mocking
        when(reconFileSummaryDao.findByFileSummaryId(rfsId)).thenReturn(fileSummary);
        when(reconFileDtlsDao.getAllReconFileData(rfsId)).thenReturn(reconList);
        when(merchantOrderPaymentDao.getMatchedData(rfsId)).thenReturn(paymentList);

        doNothing().when(reconFileDtlsDao).updateReconStatus(anyString(), anyList());
        doNothing().when(reconFileSummaryDao).save(any(ReconFileSummaryDto.class));
        doNothing().when(reconResultProcessorService).reconStatusPublisher(any(ReconResultDto.class));

        // Run
        reconciliationService.performRecon(rfsId);

        // Verify
        verify(reconFileSummaryDao).findByFileSummaryId(rfsId);
        verify(reconFileDtlsDao).getAllReconFileData(rfsId);
        verify(merchantOrderPaymentDao).getMatchedData(rfsId);
        verify(reconFileDtlsDao, atLeastOnce()).updateReconStatus(anyString(), anyList());
        verify(reconFileSummaryDao).save(any(ReconFileSummaryDto.class));
        verify(reconResultProcessorService).reconStatusPublisher(any(ReconResultDto.class));
    }

    @Test
    void performRecon_shouldHandleExceptionAndUpdateStatusAsFail() {
        UUID rfsId = UUID.randomUUID();
        ReconFileSummaryDto summaryDto = new ReconFileSummaryDto();
        summaryDto.setRfsId(rfsId);

        when(reconFileSummaryDao.findByFileSummaryId(rfsId)).thenReturn(summaryDto);
        when(reconFileDtlsDao.getAllReconFileData(rfsId)).thenThrow(new RuntimeException("DB failure"));

        reconciliationService.performRecon(rfsId);

        verify(reconFileSummaryDao).save(argThat(dto -> dto.getReconStatus() == Status.FAIL));
    }
}
