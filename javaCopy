@Service
public class ReconService {

    @Autowired
    private MerchantOrderPaymentRepository mopRepository;

    @Autowired
    private ReconFileDitlRepository reconFileDitlRepository;

    public ReconResultDTO processReconciliation() {
        ReconResultDTO result = new ReconResultDTO();

        List<MerchantOrderPayment> mopList = mopRepository.findAll();
        List<ReconFileDitl> reconList = reconFileDitlRepository.findAll();

        // Build MOP Map (ATRN -> MerchantOrderPayment)
        Map<String, MerchantOrderPayment> mopMap = mopList.stream()
            .collect(Collectors.toMap(MerchantOrderPayment::getAtrn, Function.identity()));

        // Build Recon Map (ATRN -> List<ReconFileDitl>)
        Map<String, List<ReconFileDitl>> reconMap = new HashMap<>();
        for (ReconFileDitl recon : reconList) {
            reconMap.computeIfAbsent(recon.getAtrn(), k -> new ArrayList<>()).add(recon);
        }

        // Process Matching
        for (Map.Entry<String, List<ReconFileDitl>> entry : reconMap.entrySet()) {
            String atrn = entry.getKey();
            List<ReconFileDitl> reconRecords = entry.getValue();

            if (mopMap.containsKey(atrn)) {
                if (reconRecords.size() == 1) {
                    result.getMatchedReconRecords().addAll(reconRecords);
                } else {
                    result.getDuplicateReconRecords().addAll(reconRecords);
                }
            } else {
                result.getUnmatchedReconRecords().addAll(reconRecords);
            }
        }

        // Set counts
        result.setMatchedCount(result.getMatchedReconRecords().size());
        result.setUnmatchedCount(result.getUnmatchedReconRecords().size());
        result.setDuplicateCount(result.getDuplicateReconRecords().size());

        return result;
    }
}



public class ReconResultDTO {

    private long matchedCount;
    private long unmatchedCount;
    private long duplicateCount;

    private List<ReconFileDitl> matchedReconRecords;
    private List<ReconFileDitl> unmatchedReconRecords;
    private List<ReconFileDitl> duplicateReconRecords;

    public ReconResultDTO() {
        this.matchedReconRecords = new ArrayList<>();
        this.unmatchedReconRecords = new ArrayList<>();
        this.duplicateReconRecords = new ArrayList<>();
    }

    // Getters and Setters
}

@Repository
public interface ReconRepository extends JpaRepository<ReconFileDitl, Long> {

    @Query(value = "SELECT r.atrn, COUNT(*) as count " +
                   "FROM recon_file_ditl r " +
                   "JOIN merchant_order_payment m ON r.atrn = m.atrn " +
                   "GROUP BY r.atrn " +
                   "HAVING COUNT(*) = 1", nativeQuery = true)
    List<Object[]> findMatchedATRNs();

    @Query(value = "SELECT r.atrn, COUNT(*) as count " +
                   "FROM recon_file_ditl r " +
                   "LEFT JOIN merchant_order_payment m ON r.atrn = m.atrn " +
                   "WHERE m.atrn IS NULL " +
                   "GROUP BY r.atrn", nativeQuery = true)
    List<Object[]> findUnmatchedATRNs();

    @Query(value = "SELECT r.atrn, COUNT(*) as count " +
                   "FROM recon_file_ditl r " +
                   "JOIN merchant_order_payment m ON r.atrn = m.atrn " +
                   "GROUP BY r.atrn " +
                   "HAVING COUNT(*) > 1", nativeQuery = true)
    List<Object[]> findDuplicateATRNs();
}

@Repository
public interface MerchantOrderPaymentRepository extends JpaRepository<MerchantOrderPayment, String> {

    List<MerchantOrderPayment> findByAtrn(String atrn);
}

@Repository
public interface ReconFileDitlRepository extends JpaRepository<ReconFileDitl, Long> {

    List<ReconFileDitl> findByAtrn(String atrn);
}



@Service
public class ReconService {

    @Autowired
    private ReconRepository reconRepository;

    @Autowired
    private MerchantOrderPaymentRepository mopRepository;

    @Autowired
    private ReconFileDitlRepository reconFileDitlRepository;

    public List<ReconResponseDTO> getMatchedATRNs() {
        List<Object[]> rawData = reconRepository.findMatchedATRNs();
        return buildResponseDTOs(rawData);
    }

    public List<ReconResponseDTO> getUnmatchedATRNs() {
        List<Object[]> rawData = reconRepository.findUnmatchedATRNs();
        return buildResponseDTOs(rawData);
    }

    public List<ReconResponseDTO> getDuplicateATRNs() {
        List<Object[]> rawData = reconRepository.findDuplicateATRNs();
        return buildResponseDTOs(rawData);
    }

    private List<ReconResponseDTO> buildResponseDTOs(List<Object[]> rawData) {
        List<ReconResponseDTO> result = new ArrayList<>();

        for (Object[] row : rawData) {
            String atrn = (String) row[0];
            long count = ((BigInteger) row[1]).longValue();

            List<ReconFileDitl> reconRecords = reconFileDitlRepository.findByAtrn(atrn);
            List<MerchantOrderPayment> mopRecords = mopRepository.findByAtrn(atrn);

            result.add(new ReconResponseDTO(atrn, count, reconRecords, mopRecords));
        }

        return result;
    }
}


-+-+-+-+------&+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-++-+

31/5/25

1. 

@Entity
@Table(name = "merchant_order_payment")
public class MerchantOrderPayment {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(name = "atrn", unique = true)
    private String atrn;

    @Column(name = "merchant_id")
    private String merchantId;

    @Column(name = "transaction_amount")
    private Double transactionAmount;

    @Column(name = "transaction_date")
    private LocalDate transactionDate;

    @Column(name = "payment_mode")
    private String paymentMode;

    // Getters and Setters
}

2.

@Entity
@Table(name = "recon_file_ditl")
public class ReconFileDitl {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(name = "atrn")
    private String atrn;

    @Column(name = "transaction_amount")
    private Double transactionAmount;

    @Column(name = "transaction_date")
    private LocalDate transactionDate;

    @Column(name = "matched_status")
    private String matchedStatus;

    // Other fields as needed...

    // Getters and Setters
}

3.
public class ReconResultDTO {

    private long matchedCount;
    private long unmatchedCount;
    private long duplicateCount;

    private List<ReconFileDitl> matchedReconRecords;
    private List<ReconFileDitl> unmatchedReconRecords;
    private List<ReconFileDitl> duplicateReconRecords;

    public ReconResultDTO() {
        this.matchedReconRecords = new ArrayList<>();
        this.unmatchedReconRecords = new ArrayList<>();
        this.duplicateReconRecords = new ArrayList<>();
    }

    // Getters and Setters
}


4.

@Repository
public interface MerchantOrderPaymentRepository extends JpaRepository<MerchantOrderPayment, Long> {
}


5.

@Repository
public interface ReconRepository extends JpaRepository<ReconFileDitl, Long> {

    @Query(value = """
        SELECT r.atrn FROM recon_file_ditl r
        INNER JOIN merchant_order_payment m ON r.atrn = m.atrn
    """, nativeQuery = true)
    List<String> findMatchedATRNs();

    @Query(value = """
        SELECT r.atrn FROM recon_file_ditl r
        LEFT JOIN merchant_order_payment m ON r.atrn = m.atrn
        WHERE m.atrn IS NULL
    """, nativeQuery = true)
    List<String> findUnmatchedATRNs();

    @Query(value = """
        SELECT r.atrn FROM recon_file_ditl r
        WHERE r.atrn IN (
            SELECT atrn FROM recon_file_ditl GROUP BY atrn HAVING COUNT(*) > 1
        )
    """, nativeQuery = true)
    List<String> findDuplicateATRNs();

    @Modifying
    @Transactional
    @Query(value = "UPDATE recon_file_ditl SET matched_status = :status WHERE atrn IN (:atrns)", nativeQuery = true)
    int updateMatchedStatus(@Param("status") String status, @Param("atrns") List<String> atrns);

    List<ReconFileDitl> findByAtrnIn(List<String> atrns);
}


6.
@Service
public class ReconService {

    @Autowired
    private ReconRepository reconRepository;

    @Transactional
    public ReconResultDTO getReconSummaryAndUpdateStatus() {
        ReconResultDTO result = new ReconResultDTO();

        // 1️⃣ Matched
        List<String> matchedATRNs = reconRepository.findMatchedATRNs();
        List<ReconFileDitl> matchedRecords = matchedATRNs.isEmpty() ? List.of() : reconRepository.findByAtrnIn(matchedATRNs);
        reconRepository.updateMatchedStatus("MATCHED", matchedATRNs);
        result.setMatchedReconRecords(matchedRecords);
        result.setMatchedCount(matchedRecords.size());

        // 2️⃣ Unmatched
        List<String> unmatchedATRNs = reconRepository.findUnmatchedATRNs();
        List<ReconFileDitl> unmatchedRecords = unmatchedATRNs.isEmpty() ? List.of() : reconRepository.findByAtrnIn(unmatchedATRNs);
        reconRepository.updateMatchedStatus("UNMATCHED", unmatchedATRNs);
        result.setUnmatchedReconRecords(unmatchedRecords);
        result.setUnmatchedCount(unmatchedRecords.size());

        // 3️⃣ Duplicate
        List<String> duplicateATRNs = reconRepository.findDuplicateATRNs();
        List<ReconFileDitl> duplicateRecords = duplicateATRNs.isEmpty() ? List.of() : reconRepository.findByAtrnIn(duplicateATRNs);
        reconRepository.updateMatchedStatus("DUPLICATE", duplicateATRNs);
        result.setDuplicateReconRecords(duplicateRecords);
        result.setDuplicateCount(duplicateRecords.size());

        return result;
    }
}

7.
@RestController
@RequestMapping("/api/recon")
public class ReconController {

    @Autowired
    private ReconService reconService;

    @GetMapping("/summary")
    public ResponseEntity<ReconResultDTO> getReconSummary() {
        ReconResultDTO result = reconService.getReconSummaryAndUpdateStatus();
        return ResponseEntity.ok(result);
    }
}

8.

---------------------------------------------------------------------------------------------------------------------------------------------------
So what i did the code you provide i made some change at the time of project start like 
there is change in Table name of ReconFileDitl to RECON_FILE_DTLS , some enity field  name has been changed like atrn to ATRN_NUM , matchedStatus to reconStatus,  request you as well to make the changes in your code and let know know the reson why i am geeting that erroe

Below is my MERCHANT_ORDER_PAYMENTS table 

-----------------------------------------------------
package com.epay.rns.entity;
import com.epay.rns.util.enums.*;
import jakarta.persistence.*;
import lombok.Data;
import org.springframework.data.annotation.CreatedBy;
import org.springframework.data.annotation.CreatedDate;
import org.springframework.data.annotation.LastModifiedBy;
import org.springframework.data.annotation.LastModifiedDate;
-
import java.math.BigDecimal;
import java.util.Date;

@Data
@Entity
@Table(name = "MERCHANT_ORDER_PAYMENTS")
public class MerchantOrderPaymentEntity {

    @Id
    @Column(name = "ATRN_NUM", nullable = false, updatable = false, unique = true)
    private String atrnNumber;
    @Column(name = "MERCHANT_ID")
    private String mId;
    private String orderRefNumber;
    private String sbiOrderRefNumber;
    private String bankReferenceNumber;

    private String currencyCode;
    private BigDecimal orderAmount;
    @Column(name = "DEBIT_AMT")
    private BigDecimal debitAmount;
    private BigDecimal availableRefundAmount;
    private BigDecimal chargebackAmount;

    private String gstIn;
    private String channelBank;
    @Enumerated(EnumType.STRING)
    private PayMode payMode;
    @Column(name = "GTW_MAP_ID")
    private String pgBankCode;
    private String payProcId;
    @Column(name = "PAY_PROC_TYPE")
    private String paymodeType;
    @Column(name = "GTW_ISSUE_MECODE")
    private String gatewayIssueMECode;
    private String cin;
    @Enumerated(EnumType.STRING)
    private PaymentStatus paymentStatus;
    @Enumerated(EnumType.STRING)
    private TransactionStatus transactionStatus;
    @Enumerated(EnumType.STRING)
    private SettlementStatus settlementStatus;
    @Enumerated(EnumType.STRING)
    private TransactionRefundStatus refundStatus;
    @Enumerated(EnumType.STRING)
    private CancellationStatus cancellationStatus;
    private String chargebackStatus;
    @Lob
    private String pushResponse;
    private Date paymentSuccessDate;
    private String failReason;
    private String pushStatus;
    @CreatedBy
    private String createdBy;
    @LastModifiedBy
    private String updatedBy;
    @CreatedDate
    private Long createdDate;
    @LastModifiedDate
    private Long updatedDate;

}

Below is my RECON_FILE_DTLS Table

package com.epay.rns.entity;


import jakarta.persistence.*;
import lombok.Data;
import org.apache.hadoop.shaded.org.apache.commons.net.ntp.TimeStamp;
import org.joda.time.DateTime;
import java.math.BigDecimal;
import java.util.Date;
import java.util.UUID;
@Data
@Entity
@Table(name = "RECON_FILE_DTLS")
public class ReconFileData {

    @Id
    @GeneratedValue(strategy = GenerationType.UUID)
    private UUID rfdId;
    private UUID rfsId;
    private long  rowNumber;
    private String  recordType;
    private String  atrnNum;
    private BigDecimal paymentAmount;
    private long paymentDate;
    private String bankReferenceNumber;
    private String status;
    private String reconStatus;
    private TimeStamp reconTime;
    private String settlementStatus;
    private TimeStamp settlementTime;
    private String remark;
}
------------------------------------------------------------
Below is my Liquebase script for RECON_FILE_DTLS table

--liquibase formatted sql
--changeset shilpa :103

CREATE TABLE RECON_FILE_DTLS(
                  RFD_ID                  RAW(16) PRIMARY KEY,
                  RFS_ID                  RAW(16),
                  ROW_NUMBER              NUMBER,
                  RECORD_TYPE             VARCHAR2(100),
                  ATRN_NUM                VARCHAR2(100),
                  PAYMENT_AMOUNT          NUMBER(15, 2),
                  PAYMENT_DATE            NUMBER,
                  BANK_REFERENCE_NUMBER   VARCHAR2(100),
                  STATUS                  VARCHAR2(50),
                  RECON_STATUS            VARCHAR2(50),
                  RECON_TIME              TIMESTAMP,
                  SETTLEMENT_STATUS       VARCHAR2(50),
                  SETTLEMENT_TIME         TIMESTAMP,
                  REMARK                  VARCHAR2(500));

Below is my Lique base script for MERCHANT_ORDER_PAYMENTS

--liquibase formatted sql
--changeset RECON:108

--CREATE table MERCHANT_ORDER_PAYMENTS
CREATE TABLE MERCHANT_ORDER_PAYMENTS
  (
    MERCHANT_ID             VARCHAR2(20 BYTE) NOT NULL ENABLE,
    ORDER_REF_NUMBER        VARCHAR2(50 BYTE),
    SBI_ORDER_REF_NUMBER    VARCHAR2(50 BYTE) NOT NULL ENABLE,
    ATRN_NUM                VARCHAR2(50 BYTE) PRIMARY KEY,
    BANK_REFERENCE_NUMBER   VARCHAR2(255 BYTE),
    CURRENCY_CODE           VARCHAR2(50 BYTE) NOT NULL ENABLE,
    CHANNEL_BANK            VARCHAR2(100 BYTE),
    PAY_MODE                VARCHAR2(50 BYTE),
    GTW_MAP_ID              VARCHAR2(20 BYTE),
    PAY_PROC_ID             VARCHAR2(20 BYTE),
    PAY_PROC_TYPE           VARCHAR2(20 BYTE),
    GTW_ISSUE_MECODE        VARCHAR2(50 BYTE),
    ORDER_AMOUNT            NUMBER(20,2) NOT NULL ENABLE,
    DEBIT_AMT               NUMBER(20,2),
    AVAILABLE_REFUND_AMOUNT NUMBER(20,2),
    CHARGEBACK_AMOUNT       NUMBER(20,2) DEFAULT 0,
    TRANSACTION_STATUS      VARCHAR2(50 BYTE) NOT NULL ENABLE,
    PAYMENT_STATUS          VARCHAR2(50 BYTE),
    FAIL_REASON             VARCHAR2(255 BYTE),
    SETTLEMENT_STATUS       VARCHAR2(50 BYTE),
    REFUND_STATUS           VARCHAR2(50 BYTE),
    CANCELLATION_STATUS     VARCHAR2(50 BYTE),
    CHARGEBACK_STATUS       VARCHAR2(50 BYTE),
    CIN                     VARCHAR2(50 BYTE),
    GST_IN                  VARCHAR2(50 BYTE),
    PUSH_STATUS             VARCHAR2(10 BYTE),
    POOLING_STATUS          VARCHAR2(10 BYTE) DEFAULT 'P',
    PUSH_RESPONSE CLOB,
    PAYMENT_SUCCESS_DATE    DATE,
    CREATED_DATE            NUMBER NOT NULL ENABLE,
    CREATED_BY              VARCHAR2(100 BYTE) NOT NULL ENABLE,
    UPDATED_BY              VARCHAR2(100 BYTE),
    UPDATED_DATE            NUMBER,
    PARTITION_DATE          DATE GENERATED ALWAYS AS (TO_DATE('1970-01-01 00:00:00', 'SYYYY-MM-DD HH24:MI:SS')+CREATED_DATE/1000/86400) VIRTUAL )
    PARTITION BY RANGE (PARTITION_DATE) INTERVAL (NUMTOYMINTERVAL(1, 'MONTH')) (PARTITION P_START VALUES LESS THAN (TO_DATE('01-01-2020','DD-MM-YYYY'))
  ) ;

-- 	Index and constraint on table MERCHANT_ORDER_PAYMENTS
CREATE INDEX SBI_REF_NUM_INDX ON MERCHANT_ORDER_PAYMENTS (SBI_ORDER_REF_NUMBER)  ;
CREATE INDEX ORDER_REF_NUMBER_INDX ON MERCHANT_ORDER_PAYMENTS (ORDER_REF_NUMBER)  ;
CREATE INDEX CREATED_DATEINDX ON MERCHANT_ORDER_PAYMENTS (CREATED_DATE)  ;
CREATE INDEX TRANSACTION_STATUS_INDX ON MERCHANT_ORDER_PAYMENTS (TRANSACTION_STATUS)  ;
-----------------------------------------
Below is the service class

package com.epay.rns.service;

import com.epay.rns.dao.MerchantOrderPaymentDao;
import com.epay.rns.dto.MerchantOrderPaymentDto;
import com.epay.rns.dto.ResponseDto;
import com.epay.rns.entity.ReconFileData;
import com.epay.rns.repository.ReconDataRepository;
import com.sbi.epay.logging.utility.LoggerFactoryUtility;
import com.sbi.epay.logging.utility.LoggerUtility;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;

import java.util.*;
import java.util.function.Function;
import java.util.stream.Collectors;

@Service
@RequiredArgsConstructor
public class ProcessDataService {

    private final LoggerUtility log = LoggerFactoryUtility.getLogger(this.getClass());
    private final MerchantOrderPaymentDao merchantOrderPaymentDao;
    private final ReconDataRepository reconDataRepository;

    public ResponseDto process2(){
        long startTime = System.currentTimeMillis();
        ResponseDto result = new ResponseDto();


        List<String> matchedATRNs= reconDataRepository.findMatchedATRNs();
        List<ReconFileData> matchedRecords = matchedATRNs.isEmpty()? List.of():reconDataRepository.findByAtrnNumIn(matchedATRNs);
        long frequency = startTime - System.currentTimeMillis();
        System.out.println("Time to get the matched data from db : "+ frequency);
        reconDataRepository.updateMatchedStatus("MATCHED",matchedATRNs);
        result.setMatchedReconRecode(matchedRecords);
        result.setMatchedCount(matchedRecords.size());

        long startTime1 = System.currentTimeMillis();
        List<String> unmatchedATRNs =reconDataRepository.findUnmatchedATRNs();
        List<ReconFileData> unmatchedRecords= unmatchedATRNs.isEmpty()? List.of():reconDataRepository.findByAtrnNumIn(unmatchedATRNs);
        long frequency1 = startTime1 - System.currentTimeMillis();
        System.out.println("Time to get the unmatched data from db : "+ frequency1);
        reconDataRepository.updateMatchedStatus("UNMATCHED",unmatchedATRNs);
        result.setUnmatchedReconRecode(unmatchedRecords);
        result.setUnMatchedCount(unmatchedRecords.size());



        long startTime2 = System.currentTimeMillis();
        List<String> duplicateATRNs =reconDataRepository.findDuplicateATRNs();
        List<ReconFileData> duplicateRecords= duplicateATRNs.isEmpty() ? List.of(): reconDataRepository.findByAtrnNumIn(duplicateATRNs);
        long frequency2 = startTime2 - System.currentTimeMillis();
        System.out.println("Time to get the duplicate data from db : "+ frequency2);
        reconDataRepository.updateMatchedStatus("DUPLICATE",duplicateATRNs);
        result.setDuplicateReconRecode(duplicateRecords);
        result.setDuplicateCount(duplicateRecords.size());

        System.out.println("Time to run recon process :" +(startTime -System.currentTimeMillis()) );
        return result;
    }
}
-----------------------------------------------------------------
below is Repository class

package com.epay.rns.repository;
import com.epay.rns.entity.ReconFileData;
import jakarta.transaction.Transactional;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Modifying;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;
import java.util.List;
import java.util.UUID;

@Repository
public interface ReconDataRepository extends JpaRepository<ReconFileData, UUID> {

    @Query(value = """
        SELECT r.ATRN_NUM FROM RECON_FILE_DTLS r
        INNER JOIN MERCHANT_ORDER_PAYMENTS m ON r.ATRN_NUM = m.ATRN_NUM
    """, nativeQuery = true)
    List<String> findMatchedATRNs();

    @Query(value = """
        SELECT r.ATRN_NUM FROM RECON_FILE_DTLS r
        LEFT JOIN MERCHANT_ORDER_PAYMENTS m ON r.ATRN_NUM = m.ATRN_NUM
        WHERE m.ATRN_NUM IS NULL
    """, nativeQuery = true)
    List<String> findUnmatchedATRNs();

    @Query(value = """
        SELECT r.ATRN_NUM FROM RECON_FILE_DTLS r
        WHERE r.ATRN_NUM IN (
            SELECT ATRN_NUM FROM RECON_FILE_DTLS GROUP BY ATRN_NUM HAVING COUNT(*) > 1
        )
    """, nativeQuery = true)
    List<String> findDuplicateATRNs();

    @Modifying
    @Transactional
    @Query(value = "UPDATE RECON_FILE_DTLS SET RECON_STATUS = :status WHERE ATRN_NUM IN (:ATRN_NUM)", nativeQuery = true)
    int updateMatchedStatus(@Param("status") String status, @Param("ATRN_NUM") List<String> atrnNum);

    List<ReconFileData> findByAtrnNumIn(List<String> atrnNum);
}
-----------------++++++----------------------

3/06/12

@Entity
@Table(name = "RECON_FILE_DTLS")
public class ReconFileData {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(name = "ATRN_NUM")
    private String atrnNum;

    @Column(name = "RFS_ID")
    private Long rfsId;

    @Column(name = "RECON_STATUS")
    private String reconStatus;

    // Getters, Setters
}


@Entity
@Table(name = "MERCHANT_ORDER_PAYMENT")
public class MerchantOrderPayment {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(name = "ATRN_NUM")
    private String atrnNum;

    // Getters, Setters
}


@Repository
public interface ReconDataRepository extends JpaRepository<ReconFileData, Long> {

    @Query(value = "SELECT * FROM RECON_FILE_DTLS WHERE RFS_ID = :rfsId", nativeQuery = true)
    List<ReconFileData> findAllByRfsId(@Param("rfsId") Long rfsId);

    @Modifying
    @Transactional
    @Query(value = "UPDATE RECON_FILE_DTLS SET RECON_STATUS = :status WHERE ATRN_NUM IN :atrns AND RFS_ID = :rfsId", nativeQuery = true)
    int updateStatusByAtrnsAndRfsId(@Param("status") String status,
                                    @Param("atrns") List<String> atrns,
                                    @Param("rfsId") Long rfsId);

    @Query(value = """
        SELECT r.* FROM RECON_FILE_DTLS r
        INNER JOIN MERCHANT_ORDER_PAYMENT m ON r.ATRN_NUM = m.ATRN_NUM
        WHERE r.RFS_ID = :rfsId
        """, nativeQuery = true)
    List<ReconFileData> findMatchedReconDataByRfsId(@Param("rfsId") Long rfsId);
}



@Service
@RequiredArgsConstructor
@Slf4j
public class ReconService {

    private final ReconDataRepository reconDataRepository;

    @Transactional
    public void reconcileData(Long rfsId) {
        // 1. All recon file records for given RFS_ID
        List<ReconFileData> allReconRecords = reconDataRepository.findAllByRfsId(rfsId);
        Map<String, List<ReconFileData>> allReconMap = allReconRecords.stream()
                .collect(Collectors.groupingBy(ReconFileData::getAtrnNum));

        // 2. Matched recon data (joined with merchant payment)
        List<ReconFileData> matchedReconRecords = reconDataRepository.findMatchedReconDataByRfsId(rfsId);
        Map<String, List<ReconFileData>> matchedReconMap = matchedReconRecords.stream()
                .collect(Collectors.groupingBy(ReconFileData::getAtrnNum));

        // 3. Identify ATRNs
        List<String> duplicateATRNs = matchedReconMap.entrySet().stream()
                .filter(entry -> entry.getValue().size() > 1)
                .map(Map.Entry::getKey)
                .toList();

        List<String> matchedATRNs = matchedReconMap.entrySet().stream()
                .filter(entry -> entry.getValue().size() == 1)
                .map(Map.Entry::getKey)
                .filter(atrn -> !duplicateATRNs.contains(atrn)) // Exclude duplicates from matched
                .toList();

        List<String> unmatchedATRNs = allReconMap.keySet().stream()
                .filter(atrn -> !matchedReconMap.containsKey(atrn))
                .toList();

        // 4. Update status in batches
        updateStatusInBatch(matchedATRNs, "MATCHED", rfsId);
        updateStatusInBatch(duplicateATRNs, "DUPLICATE", rfsId);
        updateStatusInBatch(unmatchedATRNs, "UNMATCHED", rfsId);

        log.info("Reconciliation complete for RFS_ID {} - Matched: {}, Duplicate: {}, Unmatched: {}",
                rfsId, matchedATRNs.size(), duplicateATRNs.size(), unmatchedATRNs.size());
    }

    private void updateStatusInBatch(List<String> atrns, String status, Long rfsId) {
        final int batchSize = 1000;
        for (int i = 0; i < atrns.size(); i += batchSize) {
            int end = Math.min(i + batchSize, atrns.size());
            List<String> batch = atrns.subList(i, end);
            reconDataRepository.updateStatusByAtrnsAndRfsId(status, batch, rfsId);
        }
    }
}

@RestController
@RequestMapping("/api/recon")
@RequiredArgsConstructor
public class ReconController {

    private final ReconService reconService;

    @PostMapping("/reconcile/{rfsId}")
    public ResponseEntity<String> reconcileByRfsId(@PathVariable Long rfsId) {
        reconService.reconcileData(rfsId);
        return ResponseEntity.ok("Reconciliation process completed for RFS_ID: " + rfsId);
    }
}
-------------++-+++++++-------------


