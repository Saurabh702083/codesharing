Below is my code to get new merchant onboarding on my admin panel,and then send this new merchant details to Merchant Service by using webClient.
	for this in my service class i am first geting list of Merchant from my Db.
	As Merchant service requers authorization  Bearer token to acess its end point so for that we are 
	generating AdminResponse<String> merchantToken , by a post method .
	
	then we are building the OnboardingRequest that we have to pass in the body 
	
	-------------------
	@Service
@Data
@RequiredArgsConstructor
public class MerchantOnboardingService {
    private final LoggerUtility logger = LoggerFactoryUtility.getLogger(this.getClass());
    private final MerchantOnboardingDao merchantOnboardingDao;
    private final MerchantOnboardingMapper merchantMapper;
    private final MerchantServicesClient merchantServicesClient;
    private final AdminConfig adminConfig;

    public void updateMerchantOnboarding(){
        List<Merchant> merchantList= merchantOnboardingDao.getMerchantRecord();
        if(merchantList.isEmpty()){
         logger.error("No new merchant has been added.");
        } else {

            AdminResponse<String> merchantToken= merchantServicesClient.getMerchantToken(SbiAdminLoginReqDto.builder().userName(adminConfig.getAdminUsername()).password(adminConfig.getAdminPassword()).build());
            for (Merchant merchant : merchantList) {
                OnboardingRequest onboardingRequest = buildOnboardRequest(merchant);
                merchantServicesClient.onboardMerchant(onboardingRequest,merchantToken.toString());
            }
        }
    }

    private OnboardingRequest buildOnboardRequest(Merchant merchant){
        MerchantDto merchantDto = merchantMapper.toMerchantDto(merchant);
        MerchantUserDto merchantUserDto = merchantMapper.toMerchantUserDto(merchant);
        return OnboardingRequest.builder().merchant(merchantDto).user(merchantUserDto).build();
    }

}

@Component
@RequiredArgsConstructor
public class MerchantOnboardingDao {
    private final MerchantOnboardingMapper merchantOnboardingMapper;
    private final MerchantOnboardingRepository merchantOnboardingRepository;

public List<Merchant> getMerchantRecord(){
   return merchantOnboardingRepository.findByRecordStatus("N");
}

}


public class MerchantServicesClient extends ApiClient {

    private static final LoggerUtility logger = LoggerFactoryUtility.getLogger(MerchantServicesClient.class);

    public static final String MERCHANT_ONBOARDING_API_ENDPOINT = "/admin/onboarding";
    public static final String MERCHANT_ADMIN_AUTHENTICATE= "/admin/sbi/authenticate";

    @Value("${merchant.services.onboarding.token}")
    private String onboardingAccessToken;

    public MerchantServicesClient(String baseUrl) {
        super(baseUrl);
    }


    public AdminResponse<String> getMerchantToken(SbiAdminLoginReqDto sbiAdminLoginReqDto){
        return post(MERCHANT_ADMIN_AUTHENTICATE,sbiAdminLoginReqDto,new  ParameterizedTypeReference<>(){});
    }

    public void onboardMerchant(OnboardingRequest onboardingRequest,String merchantToken){
        post(MERCHANT_ONBOARDING_API_ENDPOINT,onboardingRequest,)
    }

}

@Getter
public class ApiClient {
    private final LoggerUtility logger = LoggerFactoryUtility.getLogger(this.getClass());
    private final String baseUrl;
    private final WebClient webClient;
    public static final String BEARER = "bearer";
    public static final String X_CORRELATION_ID = "X-Correlation-Id";
    public static final String CORRELATION = "correlation";
    public static final String SCENARIO = "scenario";
    public static final String OPERATION = "operation";
    public static final String LOG_EXCEPTION = "Got exception {}";
    public static final String EXTERNAL_SERVICE_ERROR_CODE = "6101";
    public static final String EXTERNAL_SERVICE_ERROR_MESSAGE = "{0} service is currently unavailable. Please try again later.";
    public static final String EXTERNAL_SERVICE = "External service";
    public static final int RESPONSE_FAILURE = 0;

    /**
     * Constructor to initialize the ApiClient with the provided base URL. It also sets up the
     * WebClient instance with the base URL for making HTTP requests.
     * In local if we have other than local host service url (e.g <a href="https://dev.epay.sbi/api/admin">dev.epay.sbi</a>) then we need to handle PKIX error.
     *
     * @param baseUrl    The base URL for the API client
     * @param corsOrigin String
     */
    public ApiClient(String baseUrl, String corsOrigin, boolean isLocalProfile) {
        this.baseUrl = baseUrl;
        if (isLocalProfile) {
            this.webClient =
                    WebClient.builder()
                            .baseUrl(baseUrl)
                            .defaultHeader(HttpHeaders.ORIGIN, corsOrigin)
                            .clientConnector(new ReactorClientHttpConnector(HttpClient.create()
                                    .secure(t -> t.sslContext(SslContextBuilder.forClient()
                                            .trustManager(InsecureTrustManagerFactory.INSTANCE)))))
                            .build();
        } else {
            this.webClient =
                    WebClient.builder()
                            .baseUrl(baseUrl)
                            .defaultHeader(HttpHeaders.ORIGIN, corsOrigin)
                            .build();
        }
    }

   
    protected HttpHeaders prepareHttpHeaders() {
        HttpHeaders headers = new HttpHeaders();
        headers.setContentType(MediaType.APPLICATION_JSON);
        headers.add(HttpHeaders.ACCEPT, MediaType.APPLICATION_JSON_VALUE);
        headers.add(X_CORRELATION_ID, MDC.get(CORRELATION));
        return headers;
    }


    protected <T, R> AdminResponse<R> post(String urlPath, T requestBody, ParameterizedTypeReference<AdminResponse<R>> typeReference) {
        try {
            URI uri = URI.create(getBaseUrl() + urlPath);
            logger.info("POST call URI: {}", uri);
            logger.debug("Request body: {}", requestBody);
            AdminResponse<R> adminResponse =
                    getWebClient()
                            .post()
                            .uri(uri)
                            .headers(httpHeaders -> httpHeaders.addAll(prepareHttpHeaders()))
                            .bodyValue(requestBody)
                            .exchangeToMono(response -> response.bodyToMono(typeReference))
                            .block();
            return validateResponse(adminResponse);
        } catch (NestedRuntimeException e) {
            logger.error(LOG_EXCEPTION, e.getMessage());
            throw new AdminException(EXTERNAL_SERVICE_ERROR_CODE, MessageFormat.format(EXTERNAL_SERVICE_ERROR_MESSAGE, getServiceName(getBaseUrl())));
        }
    }

    protected <R> AdminResponse<R> post(String urlPath, ParameterizedTypeReference<AdminResponse<R>> typeReference) {
        return post(urlPath, EMPTY, typeReference);
    }

    protected <T> AdminResponse<T> get(String urlPath, ParameterizedTypeReference<AdminResponse<T>> typeReference) {
        try {
            URI uri = URI.create(getBaseUrl() + urlPath);
            logger.info("Get call URI: {}", uri);
            AdminResponse<T> adminResponse =
                    getWebClient()
                            .get()
                            .uri(uri)
                            .headers(httpHeaders -> httpHeaders.addAll(prepareHttpHeaders()))
                            .exchangeToMono(response -> response.bodyToMono(typeReference))
                            .block();
            return validateResponse(adminResponse);
        } catch (NestedRuntimeException e) {
            logger.error(LOG_EXCEPTION, e.getMessage());
            throw new AdminException(EXTERNAL_SERVICE_ERROR_CODE, MessageFormat.format(EXTERNAL_SERVICE_ERROR_MESSAGE, getServiceName(getBaseUrl())));
        }
    }

    /**
     * @param response MerchantResponse
     * @param <T>      T
     */
    private <T> AdminResponse<T> validateResponse(AdminResponse<T> response) {
        if (nonNull(response) && RESPONSE_FAILURE == response.getStatus() && CollectionUtils.isNotEmpty(response.getErrors())) {
            logger.error("{} has sent errors: {}", getServiceName(getBaseUrl()), response.getErrors());
            throw new AdminException(response.getErrors());
        }
        return response;
    }
    /**
     * Return service name from the given baseURL
     *
     * @return String
     */
    public static String getServiceName(@NotNull String baseURL) {
        String[] urlToken = baseURL.split("/");
        return urlToken.length > 1 ? urlToken[urlToken.length - 2].substring(0, 1).toUpperCase() + urlToken[urlToken.length - 2].substring(1) : EXTERNAL_SERVICE;
    }

}


@Data
@Entity
@Table(name = "MERCHANT_INFO_VIEW")
public class Merchant {

    @Id
    @Column(name = "MERCHANT_ID")
    private String mId;
    @Column(name = "ISACTIVE")
    private String isActive;
    @Column(name = "brand_name")
    private String merchantName;
    @Column(name = "country")
    private String countryCode;
    private Integer maxAtrnCount;
    private String currency;
    @Column(name = "PREFERRED_PAYMENT_MODE")
    private String preferredPayMode;
    @Column(name = "PREFERRED_NETBANKING")
    private String preferredBank;
    private Long accessTokenExpiryTime;
    @Column(name = "MERCHANT_TANSACTION_INTERVAL")
    private Long transactionTokenExpiryTime;
    private Long orderExpiryTime;
    private String merchantVolVelFlag;
    private String multiAccountCredit;
    private String numberOfAttemptsApplicable;
    private String numberOfAttempts;
    private String isRefundApplicable;
    private Integer refundWindowDays;
    private String merchantBusinessUrl;
    private String dvpType;
    private String refundAdjustment;

}
-----------------------------------
So above code in my somewho incomplete, once i build the onboardingRequest i have to pass this request in body and merchantToken as a bearer token in authorization ,
i need you to complete this onboardMerchant of webClient method based on my above code structure. as of now this onboardMerchant method in not complete so pls dot so that i can hit this merchant service 

	


