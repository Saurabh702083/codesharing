Below is my code that will get read zip file from sftp and then upload it on the s3.

@RestController
@RequiredArgsConstructor
@RequestMapping("/gst/invoice")
public class gstInvoiceController {
    private final LoggerUtility logger = LoggerFactoryUtility.getLogger(this.getClass());
    private final GstInvoiceService gstInvoiceService;

    @PostMapping("/download")
    public CommunicationResponse<String> gstInvoiceRequest(@RequestBody GstInvoiceRequest gstInvoiceRequest){
        logger.info("Request to get gst invoice from SFTP to s3.");
       return gstInvoiceService.invoiceRequest(gstInvoiceRequest);
    }

}


@Service
@RequiredArgsConstructor
public class GstInvoiceService {
    private final LoggerUtility logger = LoggerFactoryUtility.getLogger(this.getClass());
    private final SftpClientService sftpClientService;
    private final GstInvoiceDownloadProducer gstInvoiceDownloadProducer;
    private final ObjectMapper objectMapper;
    private final FileService fileService;
    private final GstInvoiceValidation gstInvoiceValidation;

    /**
     * Processes the invoice request and uploads the relevant PDF files to S3.
     *
     * @param gstInvoiceRequest the GST invoice request
     * @return a communication response indicating the status of the operation
     */
    public CommunicationResponse<String> invoiceRequest(GstInvoiceRequest gstInvoiceRequest) {
        gstInvoiceValidation.validateGstInvoiceRequest(gstInvoiceRequest);
        GstInvoiceType type = GstInvoiceType.valueOf(gstInvoiceRequest.getInvoiceType());
        logger.info("Generate invoice for invoiceType:{}", gstInvoiceRequest.getInvoiceType());
        boolean hasGstn = isGstnListNotEmpty(gstInvoiceRequest.getGstns());
        logger.info("Processing invoices for monthYear={}, type={}, gstIns={}", gstInvoiceRequest.getMonthYear(), type, gstInvoiceRequest.getGstns());
        getAndProcessZipFile(gstInvoiceRequest.getMonthYear(),gstInvoiceRequest.getGstns(),hasGstn,type);
        return CommunicationResponse.<String>builder().data(List.of("Invoice has been successfully sent")).status(RESPONSE_SUCCESS).build();

    }



    private void getAndProcessZipFile(String monthYear, List<String> gstn, boolean hasGstIn, GstInvoiceType invoiceType){
        InputStream zipStream =  sftpClientService.getMonthlyZip(monthYear);
        ZipInputStream zis = new ZipInputStream(zipStream);
        processZipEntries(zis, invoiceType, gstn, hasGstIn,monthYear);
    }

    /**
     * Processes the ZIP entries and uploads the relevant PDF files to S3.
     *
     * @param zis      the ZIP input stream
     * @param type     the invoice type
     * @param gstns   the list of GSTNs
     * @param hasGstin whether the GSTN list is not empty
     */
    private void processZipEntries(ZipInputStream zis, GstInvoiceType type, List<String> gstns, boolean hasGstin, String monthYear)  {
        try {
            ZipEntry entry;
            while ((entry = zis.getNextEntry()) != null) {
                if (isEntryNotPdf(entry) || isEntryDirectory(entry)) {
                    continue;
                }
                ParsedInvoiceFile parsedInvoiceFile = InvoiceFileParser.parse(entry.getName(), monthYear);
                logger.info("Processing invoice upload for fileName : {}, InvoiceType : {}, GstIn : {}", parsedInvoiceFile.getFileName(), parsedInvoiceFile.getInvoiceType(), parsedInvoiceFile.getPartyGstIn());
                if (!isEntryTypeMatching(parsedInvoiceFile.getInvoiceType(), type, hasGstin) || !isGstnValid(parsedInvoiceFile.getPartyGstIn(), gstns, hasGstin)) {
                    continue;
                }
                logger.info("Uploading gstIn invoice to s3 for gstIn :{}", parsedInvoiceFile.getPartyGstIn());
                byte[] pdfBytes = ZipFileReader.readZipInputStream(zis);
                String s3Path = uploadFileOnS3(pdfBytes, parsedInvoiceFile.getFileName());
                logger.info("Sending invoice s3 path {} to report service for GSTIN : {}", s3Path, parsedInvoiceFile.getPartyGstIn());
                publishInvoice(parsedInvoiceFile, s3Path);
                zis.closeEntry();
            }
        }catch (Exception ex) {
            throw new CommunicationException(ZIP_FILE_ERROR_CODE, MessageFormat.format(ZIP_FILE_ERROR_MESSAGE , ex.getMessage()));
        }

    }

    /**
     * Uploads the PDF file to S3.
     *
     * @param fileName   the name of the file entry
     * @throws Exception if an error occurs during upload
     */
    private String uploadFileOnS3(byte[] pdfBytes, String fileName )  {
        try {

            return fileService.uploadFile(fileName, pdfBytes);
        } catch (Exception ex) {
            throw new CommunicationException(S3_UPLOAD_ERROR_CODE, MessageFormat.format(S3_UPLOAD_ERROR_MESSAGE,ex.getMessage()));
        }
    }

    /**
     * Method to publish s3 path of invoice to report service
     * @param parsedInvoiceFile ParsedInvoiceFile
     * @param s3Path String
     */
    private void publishInvoice (ParsedInvoiceFile parsedInvoiceFile, String s3Path ){
        S3UploadInvoiceResponse s3UploadInvoiceResponse= S3UploadInvoiceResponse.builder().invoiceType(parsedInvoiceFile.getInvoiceType())
                .gstIn(parsedInvoiceFile.getPartyGstIn()).monthYear(parsedInvoiceFile.getMonthYear())
                .s3Key(s3Path).build();
        try {
            String uploadInvoiceMessage = objectMapper.writeValueAsString(s3UploadInvoiceResponse);
            gstInvoiceDownloadProducer.publish(parsedInvoiceFile.getInvoiceType()+"_"+UUID.randomUUID(),uploadInvoiceMessage);
            logger.info("Successfully send the s3 path to report service");
        }catch (Exception ex){
            logger.error("Error in publishing alert", ex);
        }
    }


    private boolean isGstnListNotEmpty(List<String> gstins) {
        return !CollectionUtils.isEmpty(gstins);
    }

    private boolean isEntryNotPdf(ZipEntry entry) {
        return !entry.getName().toLowerCase().endsWith(".pdf");
    }

    private boolean isEntryDirectory(ZipEntry entry) {
        return entry.isDirectory();
    }

    private boolean isEntryTypeMatching(GstInvoiceType entryType, GstInvoiceType type, boolean hasGstin) {
        return !hasGstin || entryType == type;
    }

    private boolean isGstnValid(String gstinFromFile, List<String> gstins, boolean hasGstin) {
        return !hasGstin || (StringUtils.hasText(gstinFromFile) && gstins.contains(gstinFromFile));
    }
}

public class InvoiceFileParser {


    public static ParsedInvoiceFile parse(String filePath, String monthYear) {
        String fileName=filePath.replace("EPY_INVOICES_"+monthYear+"/","");
        if (!fileName.startsWith("Invoice-") || !fileName.endsWith(".pdf")) {
            throw new CommunicationException("","Invalid invoice filename format: " + fileName);
        }
        String withoutExt = fileName.substring(0, fileName.length() - 4);
        String[] parts = withoutExt.split("-");
        String sbiGstIn = parts[1];
        String typeIndicator = parts[2];
        String yearMonth = parts[3] + "-" + parts[4];
        String partyGstIn = parts[5];
        String invoiceRef = parts[7];

        GstInvoiceType fileType = typeIndicator.equals("0") ? GstInvoiceType.CUSTOMER_GST_INVOICE : GstInvoiceType.MERCHANT_GST_INVOICE;

        return ParsedInvoiceFile.builder().invoiceType(fileType).sbiGstIn(sbiGstIn).partyGstIn(partyGstIn).invoiceReference(invoiceRef).monthYear(yearMonth).fileName(fileName).build();
    }
}


@Service
@RequiredArgsConstructor
public class SftpClientService {

    private final LoggerUtility logger = LoggerFactoryUtility.getLogger(this.getClass());
    private final CachingSessionFactory<DirEntry> cachingSessionFactory;

    @Value("${sftp.gstIn.baseDir}")
    private String GST_INVOICE_BASE_DIR;
 public InputStream getMonthlyZip(String monthYear) {
        try {
            Path zipPath = Path.of(GST_INVOICE_BASE_DIR, "EPY_INVOICES_"+monthYear + ".zip");
            logger.info("Reading local zip file: {}", zipPath.toAbsolutePath());
            if (!Files.exists(zipPath)) {
                throw new CommunicationException(SFTP_ERROR_CODE, MessageFormat.format(SFTP_ERROR_MESSAGE,"Error while finding zip file for monthYear: " + monthYear,FILE_NOT_FOUND_ERROR_CODE, FILE_NOT_FOUND));
            }
            return new FileInputStream(zipPath.toFile());
        } catch (FileNotFoundException e) {
            throw new CommunicationException(SFTP_ERROR_CODE, MessageFormat.format(SFTP_ERROR_MESSAGE,"Error opening local zip file for monthYear: " + monthYear, e.getMessage()));
        }
    }
}


@Component
@RequiredArgsConstructor
public class ZipFileReader {

    public static byte[] readZipInputStream (ZipInputStream zis) throws Exception {
        ByteArrayOutputStream buffer = new ByteArrayOutputStream();
        byte[] tmp = new byte[4096];
        int read;
        while ((read = zis.read(tmp)) != -1) {
            buffer.write(tmp, 0, read);
        }
        return buffer.toByteArray();
    }

}


In above code i need to make some changes 
1. i want to make upload on s3 and publish part async. as there will be throusnd of files inside the zip, and it will take some time if we process this one by one , 
for this we can use virtual thread to do this task async or we can upload in bulk.
2. in parse method we have to handle  below senario , as if some file which is not pdf it will throw error , we have to skip that file not throw an error as it will not process other remaining file
if (!fileName.startsWith("Invoice-") || !fileName.endsWith(".pdf")) {
            throw new CommunicationException("","Invalid invoice filename format: " + fileName);
        }
